[
  {
    "id": 1,
    "text": "Авторы: theuRay (Андрей Холявка), Ankylosaurus (Анкилозавр), Sargeras (Саргерас)\n\nВ данном учебнике содержатся основы Lua (Луа), обучающий материал для начинающих и некоторые возможности для более опытных авторов. \n\nУчебник будет постепенно пополняться различными материалами, так что проверяйте его время от времени — вдруг найдете интересную механику для себя.\n\n   *   *   *\n\nУважаемые авторы! По ряду причин ваши вопросы в комментариях к учебникам могут долгое время оставаться без внимания. Для оперативной помощи рекомендуем задавать их в нашей группе ВК, в беседе авторов или в дискорде ",
    "answers": [
      {
        "id": 5,
        "text": "Начать ознакомление",
        "lua_do": "function lua_do()\n  g.formatText = 1\nend"
      },
      {
        "id": 1,
        "text": " ",
        "comment": true
      },
      {
        "id": 1,
        "text": "Ссылка на Чат по Луа",
        "comment": false,
        "url": "https://vk.me/join/AJQ1d/8cQQsIq/EvWxoJMvyG"
      },
      {
        "id": 1,
        "text": "Группа ТК в ВК",
        "url": "https://vk.com/text_quest_shaba"
      },
      {
        "id": 1,
        "text": "Сервер ТК в Discord",
        "comment": false,
        "url": "https://discord.com/invite/8DaZ3YHKk8"
      },
      {
        "id": 1,
        "text": "Канал ТК в Телеграме",
        "url": "https://t.me/shaba_quest"
      },
      {
        "id": 1,
        "text": "Чат ответов на вопросы в Телеграме",
        "url": "https://t.me/luartirs"
      },
      {
        "id": 22,
        "text": "Поиск по квесту",
        "run": [
          22
        ]
      },
      {
        "super_calculate": false,
        "lua_do": "function lua_do()\ng[\"autorun after\"] = 22\nend",
        "text": "Поиск по квесту",
        "id": 1,
        "calculate": true
      }
    ]
  },
  {
    "id": 2,
    "text": "   Message — это всплывающее окно с информацией, которое появляется на короткое время. Вы должны были его видеть, при входе на эту страницу. \n\n   message(\" \")\n\n   Всё, что будет вписано внутри скобок — будет отображено в поле сообщения как текст. \n   Message может быть вписан как самостоятельный код, и также в составе с другим кодом.\n\n   function lua_do()\n       message(\"Привет, читатель!\")\n   end\n\n   function lua_do()\n       a = 5\n       if b < 3 then\n           c = a <plus> b\n       end\n       message(\"Привет, читатель!\")\n   end",
    "answers": [
      {
        "comment": false,
        "lua_do": "function lua_do()\n    message(\"Привет, читатель! (повтор)\")\nend",
        "instant": true,
        "id": 2,
        "text": "Показать его еще раз"
      },
      {
        "id": 2,
        "text": "  ",
        "comment": true
      },
      {
        "id": 23,
        "text": "А посложнее можно? ",
        "lua_do": "function lua_do()\n    if not gold then\n        gold = 5\n    end\nend"
      },
      {
        "id": 29,
        "text": "Как увеличить время показа message? "
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 3,
    "text": "Диалоговые окна — это дополнительные окна которые несут следующее содержание: заголовок, текст и выбор/выборы.\n\nДиалоговое окно открывается поверх текущей страницы, что позволяет разнообразить возможности их применения: от простого информационного поля с пояснительной информацией, и до выдора действий с исполнением вложенного кода.",
    "answers": [
      {
        "id": 3,
        "text": "Пример диалогового окна как поля информации.",
        "comment": false,
        "lua_do": "function lua_do()\n    dialog{\n        header = \"Лесной волк\",\n        text = \"Данный вид предпочитает охотиться стаей, и загоняет свою жертву в ловушку. Одиночки лесных волков встречают крайне редко, в отличии от их степных и горных собратьев.\",\n        answers = {\n            {\n                text = \"Понял\",\n                pressListener = function()\n                    hideDialog()\n                end\n            }\n        }\n    }\nend"
      },
      {
        "id": 3,
        "text": "   Как записано в кнопке:\n\n   function lua_do()\n       dialog{\n           header = \"Лесной волк\", \n           text = \"Данный вид предпочитает охотиться стаей, и загоняет свою жертву в ловушку. Одиночки лесных волков встречают крайне редко, в отличии от их степных и горных собратьев.\", \n           answers = {\n               {\n                   text = \"Понял\", \n                   pressListener = function()\n                       hideDialog()\n                   end\n               }\n           }\n       }\n   end  \n\n",
        "comment": true
      },
      {
        "id": 3,
        "text": "Пример диалогового окна с несколькими выборами.",
        "comment": false,
        "lua_do": "function lua_do()\n    dialog{\n        header = \"Вам представился выбор!\",\n        text = \"Вы нашли чёрный сундучок. Возможно внутри лежат деньги или какое-нибудь украшение, но вполне можеть быть, что это ловушка. Хотите открыть?\",\n        answers = {\n            {\n                text = \"Да, открыть.\",\n                pressListener = function()\n                    hideDialog()\n                end\n            },\n            {\n                text = \"Нет, пройти мимо.\",\n                pressListener = function()\n                    hideDialog()\n                end\n            }\n        }\n    }\nend"
      },
      {
        "id": 3,
        "text": "   Как записано в кнопке:\n\n   function lua_do()\n       dialog{\n           header = \"Вам представился выбор!\", \n           text = \"Вы нашли чёрный сундучок. Возможно внутри лежат деньги или какое-нибудь украшение, но вполне можеть быть, что это ловушка. Хотите открыть?\", \n           answers = {\n               {\n                   text = \"Да, открыть.\",\n                   pressListener = function()\n                       hideDialog()\n                   end\n               }, \n               {\n                   text = \"Нет, пройти мимо.\",\n                   pressListener = function() \n                       hideDialog()\n                   end\n               }\n           }\n       }\n   end",
        "comment": true
      },
      {
        "id": 4,
        "text": "А как же вписать последствия выбора? ",
        "var_set": [
          "hp",
          100
        ]
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 4,
    "text": "   ",
    "answers": [
      {
        "id": 4,
        "text": "Твоё здоровье:",
        "comment": true,
        "var_show": [
          "hp"
        ]
      },
      {
        "comment": false,
        "instant": true,
        "lua_do": "function lua_do()\n    dialog{\n        header = \"Вам представился выбор!\", \n        text = \"Перед тобой сундук с ловушкой. Так как ты не сможешь её обезвредить, то остаётся либо активировать ловушку, либо оставить сундук и идти дальше.\", \n        answers = {\n            {\n                text = \"Активировать ловушку.\",\n                pressListener = function()\n                hp = hp - 20\n                showPage{ id = g.current_id, transition = \"instant\" }\n                    hideDialog() \n                end\n            }, \n           {\n                text = \"Оставить сундук и идти дальше.\", \n                pressListener = function()\n                    hideDialog()\n                end\n            }\n        }\n    }\nend",
        "text": "Событие!",
        "var_need": [
          "hp",
          1
        ],
        "id": 4
      },
      {
        "comment": false,
        "id": 4,
        "text": "Восстановить здоровье",
        "var_less": [
          "hp",
          1
        ],
        "var_set": [
          "hp",
          100
        ]
      },
      {
        "id": 4,
        "text": "   При нажатии на \"Событие\" появляется диалоговое окно, и если активировать ловушку, то происходит потеря здоровья, то есть исполнение авторского кода.\n   Что же записано в ответе?\n\n   function lua_do()\n       dialog{\n           header = \"Вам представился выбор!\", \n           text = \"Перед тобой сундук с ловушкой. Так как ты не сможешь её обезвредить, то остаётся либо активировать ловушку, либо оставить сундук и идти дальше.\", \n           answers = {\n               {\n                   text = \"Активировать ловушку.\",\n                   pressListener = function() \n                       hp = hp - 20\n                       showPage{ id = g.current_id, transition = \"instant\" }\n                       hideDialog()\n                   end\n               }, \n               {\n                   text = \"Оставить сундук и идти дальше.\", \n                   pressListener = function()\n                       hideDialog()\n                   end\n               }\n           }\n       }\n   end\n\n   Что же изменилось? \n   В первом ответе (\"активировать ловушку\") после функции pressListener появился авторский код: \n   \n   hp = hp - 20\n   showPage{ id = g.current_id, transition = \"instant\" }\n   \n   Это простой вариант для представления, но под этой функцией можно написать любой свой код, даже с самыми замысловатыми расчетами или рандомом. ShowPage вновь выступает для мгновенной отрисовки изменений, либо для перехода на другую страницу. \n   Для перехода на другую страницу нужно заменить g.current_id на номер страницы, куда должно отправить читателя:\n\n   showPage{ id = 5, transition = \"instant\" }",
        "comment": true
      },
      {
        "id": 4,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 5,
    "text": "Для начала:",
    "answers": [
      {
        "id": 87,
        "text": "База Lua\n(что это, и как этим пользоваться?)",
        "middle_answer": false
      },
      {
        "id": 12,
        "text": "Обучение основам Луа (уроки от Завра)",
        "middle_answer": false
      },
      {
        "id": 5,
        "text": "\nПростые опции:",
        "comment": true
      },
      {
        "id": 7,
        "text": "Удаление пустых функций lua",
        "var_set": [
          "a1",
          0,
          "a2",
          0
        ]
      },
      {
        "id": 60,
        "text": "Локальные переменные"
      },
      {
        "id": 74,
        "text": "Глобальные переменные"
      },
      {
        "id": 58,
        "text": "Операции проверки наличия переменной"
      },
      {
        "id": 24,
        "text": "Округление значений переменных при сложных расчетах"
      },
      {
        "id": 41,
        "text": "Конкатенация, или объединение текста"
      },
      {
        "id": 67,
        "text": "Перенос строки <s>\n"
      },
      {
        "id": 5,
        "text": "\nТаблицы/массивы:",
        "comment": true
      },
      {
        "id": 54,
        "text": "Работа с таблицами/массивами"
      },
      {
        "id": 38,
        "text": "Копирование таблицы table.copy2"
      },
      {
        "id": 68,
        "text": "Сортировка массива table.sort",
        "lua_do": "function lua_do()\n    tableA, sorted = nil, false\nend"
      },
      {
        "id": 73,
        "text": "Итераторы",
        "need": [
          777777777
        ]
      },
      {
        "id": 78,
        "text": "math.max / math.min"
      },
      {
        "id": 5,
        "text": "\nРандом (Random):",
        "comment": true
      },
      {
        "id": 30,
        "text": "Рандом и их типы"
      },
      {
        "id": 63,
        "text": "RandomFrom ...",
        "lua_do": "function lua_do()\n    a = nil\nend"
      },
      {
        "id": 36,
        "text": "Выбор рандом-цели"
      },
      {
        "id": 72,
        "text": "Рандом для дробных чисел"
      },
      {
        "id": 71,
        "text": "Реализация оператора \"var random from weight\" на lua"
      },
      {
        "id": 5,
        "text": "\nСообщения, уведомления, диалоги:",
        "comment": true
      },
      {
        "id": 57,
        "text": "Уведомление (alert)"
      },
      {
        "id": 2,
        "text": "Всплывающие сообщения (message)",
        "lua_do": "function lua_do()\n    message(\"   Привет, читатель!\")\nend"
      },
      {
        "id": 3,
        "text": "Диалоговые окна (dialog)"
      },
      {
        "id": 52,
        "text": "Изменение стандартного фона диалогового окна"
      },
      {
        "id": 44,
        "text": "Дополнительные опции диалогового окна"
      },
      {
        "id": 5,
        "text": "\nРабота с картинками:",
        "comment": true
      },
      {
        "id": 79,
        "text": "Добавление картинок и их масштабирование "
      },
      {
        "id": 85,
        "text": "Покраска объектов и картинок"
      },
      {
        "id": 5,
        "text": "\nСложные эффекты:",
        "comment": true
      },
      {
        "id": 31,
        "text": "Задержка Delay",
        "lua_do": "function lua_do()\n    ff = 0\n    text = \"\"\nend"
      },
      {
        "id": 33,
        "text": "Эффекты вспышки/затемнения"
      },
      {
        "id": 46,
        "text": "Правое сайд-меню",
        "need": [
          9999
        ],
        "lua_do": "function lua_do()\n    g.side_menu = 47\n    g.right_icon = \"5fee0cf29b66.png\"\n    g.menu_background = \"e5989a1409c7.jpg\"\nend"
      },
      {
        "id": 65,
        "text": "os.date - использование даты и времени с телефона читателя"
      },
      {
        "id": 5,
        "text": "\nПрочие опции:",
        "comment": true
      },
      {
        "id": 6,
        "text": "Свой текст в виджетах <plus> исполнение кода Луа при нажатии на виджет"
      },
      {
        "id": 49,
        "text": "Создание поля для ввода значения читателем (textBox и textField)"
      },
      {
        "id": 61,
        "text": "Слайдер"
      },
      {
        "id": 76,
        "text": "Вкладки (tabBar) "
      },
      {
        "id": 53,
        "text": "Модули Луа",
        "need": [
          53
        ]
      },
      {
        "id": 84,
        "text": "g.reloadFunctions (автозапуск страницы с функциями) "
      },
      {
        "id": 5,
        "text": "  ",
        "comment": true
      },
      {
        "id": 1,
        "text": "[ Закрыть учебник ]"
      },
      {
        "id": 5,
        "text": "   ",
        "calculate": true,
        "super_calculate": false
      },
      {
        "id": 8,
        "text": "Вкладки на странице",
        "need": [
          9999
        ]
      },
      {
        "id": 35,
        "text": "инфо по вкладкам",
        "need": [
          9999
        ]
      },
      {
        "id": 5,
        "text": "   ",
        "calculate": true,
        "super_calculate": false
      },
      {
        "id": 47,
        "text": "...сайд-меню...",
        "need": [
          9999
        ]
      }
    ]
  },
  {
    "id": 6,
    "text": "   g[\"lua_text_widget\"..widgetId] = [[lua_text_widget = function()\n       return my_text\n   end]]\n    Заменяет собой стандартную конструкцию текста виджета, так что все нужные переменные необходимо вставлять вручную.\n   Вставляется в lua_do на той же кнопке, где, например, widget_init (но не обязательно, можно по ходу квеста менять как захочется). С самим widget_init никак не связано, но работает в связке с widget_show.\n\n   Двойные скобки — создание строки без учёта эскейп-последовательности. То есть, можно не заморачиваться с переносами через <s>\n, а просто нажимать энтер (перенос строки). Строка будет создана такая, какой ты ее видишь на экране. Если у тебя в коде встречаются еще одни двойные скобки, можно использовать не [[   ]], a [=[   ]=] чтобы не было конфликтов.\n   В этих скобках должна быть написана функция, которая выполнится для замены стандартного текста.\n\n   Зачем нужна теория? Чтобы на практике было проще понять происходящее. Приступим? ",
    "answers": [
      {
        "lua_do": "function lua_do()\n    g[\"lua_text_widget\".. \"w1\"] = [[lua_text_widget = function()\n        return \"Монет: \" .. gold\n    end]] \nend",
        "id": 10,
        "text": "Практика с виджетами",
        "widget": [
          "w1",
          "http://188.120.236.127/hc/island/lopata.png",
          "text after number"
        ],
        "var_set": [
          "gold",
          5
        ]
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 7,
    "text": "   Сейчас при ненадобности функций lua_do, lua_if или lua_text — их можно удалить. Для этого достаточно вписать пустое значение функции или стереть её до этого пустого значения. Вот пример для удаления функции lua_do:\n\nfunction lua_do()\nend\n\n   Сохранение функции в таком виде удалит её отображение на ответе. \n\n   Предлагаю опробовать на практике и посмотреть как это примерно выглядит:",
    "answers": [
      {
        "lua_text": "function lua_text()\n    local text = \"...Написанный текст...\"\n    if a1 == 0 then\n        text = text .. \"<s>\n<s>\nfunction lua_do()<s>\n    a = b <plus> c<s>\nend\"\n    end\n    if a2 == 0 then\n        text = text .. \"<s>\n<s>\nfunction lua_if()<s>\n    return a > 0 <s>\nend\"\n    end\n    return text\nend",
        "id": 7,
        "instant": true,
        "comment": false,
        "text": " error 789"
      },
      {
        "id": 7,
        "text": "  ",
        "comment": true
      },
      {
        "comment": false,
        "var_equal": [
          "a1",
          0
        ],
        "id": 7,
        "text": "Вписать пустой код:\n   function lua_do()\n   end",
        "var_set": [
          "a1",
          1
        ]
      },
      {
        "comment": false,
        "var_equal": [
          "a1",
          1
        ],
        "id": 7,
        "text": "Вписать код:\n   function lua_do()\n       a = b <plus> c\n   end",
        "var_set": [
          "a1",
          0
        ]
      },
      {
        "comment": false,
        "var_equal": [
          "a2",
          0
        ],
        "id": 7,
        "text": "Вписать пустой код:\n   function lua_if()\n   end",
        "var_set": [
          "a2",
          1
        ]
      },
      {
        "comment": false,
        "var_equal": [
          "a2",
          1
        ],
        "id": 7,
        "text": "Вписать код:\n   function lua_if()\n       return a > 0\n   end",
        "var_set": [
          "a2",
          0
        ]
      },
      {
        "id": 7,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 8,
    "text": "   Чтобы задать вкладки нужно указать их количество в специальной переменной:\n\n   g.numberOfTabs = 5\n\n   Теперь нужно указать картинкe иконки для каждой вкладки:\n\n   g.Tab1IconImage = \"http://lalala.jpg\"\n   g.Tab2IconImage = \"http://lalala2.jpg\"\n   ...\n\n   Теперь игра может отрисовать все пять вкладок снизу экрана, растянув иконки так, чтобы вместе они заняли 100% ширины и 5% высоты.\n\n   При переключении вкладки не срабатывают калькулейты, так что имейте это в виду.\n\n   Это может быть запись ?tab [2,55], что означает найти в истории 2 вкладки посещение 55 страницы.\n\nЗагвоздка с авторанами для вкладок. Если номер вкладки меняется калькулейтом на странице, то на этой странице не будут работать новые автораны, так как ответы с авторанных страниц добавляются в текущую таблицу до того, как просчитываются калькулейты. В общем-то не столь критично, хотя для рядового пользователя такая условность будет выглядеть не очень логично. Возможности пофиксить нет, разве что вводить какие-нибудь суперкалькулейты приоритетность. повыше.",
    "answers": []
  },
  {
    "id": 9,
    "text": "   Lua один из самых демократичных языков в рассматриваемом вопросе. Он до последнего будет пытаться перевести один тип данных в другой и, только если у него это не получится, сообщит об ошибке.\n   Например, если вы присвоили некой переменной текст, содержащий одни цифры, и потом попробуете использовать значение этой переменной в математических операциях, Lua без проблем обработает его как число.\n   А ведь строка (последовательность символов) и число — это разные типы данных.\n   Lua — язык с динамической типизацией. Что сии заумные слова означают? Что каждое значение содержит тип в самом себе, а любой переменной можно присвоить значение любого типа. При этом может получиться так, что переменная сперва хранит данные одного типа, потом другого, потом третьего. В Lua это вполне допустимо. Хотя, лично я бы настоятельно не рекомендовал так делать без особой на то нужды.\n   Кажется, что я говорю в общем-то банальные вещи? Это отнюдь не так: во многих языках программирования тип данных, которые может хранить переменная, однозначно определяется при её объявлении. После этого она не может хранить данные другого типа. И да, строки в таких языках не могут быть использованы в качестве числа.\n   Какие же типы данных поддерживаются в Lua? Их не так уж и много. Поговорим о каждом в отдельности.\n   nil — отсутствие значения.\n   Тип данных nil мы уже упоминали в одной из прошлых страниц. Напомню, что он может иметь только одно значение — nil.\n   Задача nil состоит в том, чтобы принципиально отличаться от всех других значений, сигнализируя, что значение как таковое отсутствует. Любая переменная до присвоения ей первого значения равна nil.\n   А следующая запись просто удалит переменную, сделает её как бы никогда не существовавшей, такой же, какой она была до первого к ней обращения:\n\n   var1 = nil\n\n   После этого память устройства, отведённая под обслуживание этой переменной, будет освобождена.\n\n   Boolean — логические значения.\n   Этот тип данных поддерживает только два значения — true (истина) и false (ложь). Эти значения называются, логическими или булевыми.\n   Они используются в управляющих условных конструкциях: в зависимости от их значения программа будет по-разному выполняться.\n   Особенностью Lua является то, что при проверке на true или false в их качестве могут рассматриваться любые другие значения.\n   Например, при проверке условия значение nil приравнивается к false, а любое другое значение (кроме самого false) приравнивается к true.\n   Таким образом, нулевое значение или пустая строка (\"\") также будут рассмотрены в качестве true.\n\n   Number — числа.\n   В Lua этим типом представлены вещественные числа — числа двойной точности с плавающей запятой (точкой). Это единственный числовой формат, представленный в этом языке программирования. Здесь нет целочисленного типа, как во многих других языках, а также — чисел одинарной точности.\n   Я уже упоминал, что Lua отличается тем, что замечательно использует универсальные средства там, где другие языки задействуют специальные. Это как раз один из таких случаев. Вещественные числа здесь с успехом применяются при организации циклов, и никаких ошибок при этом не возникает.\n   Если модуль числа (его значение без учёта знака) находится в диапазоне от 0.000 1 до 99 999 999 999 999, такие числа записываются привычным для нас образом. Если число выходит за эти пределы, Lua автоматически переведёт его в так называемую экспоненциальную запись.\n   Запись числа 463 364 364 367 947 будет выглядеть так:\n\n   4.6336436436795e<plus>14\n\n   Так как число превысило значение в 99 триллионов (максимальное значение, укладывающееся в 14 знаков), запись приобретает вид, в котором число округлено до 14 значащих цифр, а порядок (число после \"e<plus>\") показывает степень, в которую нужно возвести 10, чтобы умножить на полученное значение число, стоящее в первой части записи.\n   Если вам это сложновато переварить, скажу проще: число после \"е<plus>\" показывает, на сколько знаков нужно «сдвинуть» запятую вправо, при необходимости добавляя нули после значащих цифр. Например запись 1.23e<plus>15 будет эквивалентна числу 1 230 000 000 000 000.\n   Я думаю, вы уже поняли, что пробелы между группами цифр я добавляю здесь исключительно для удобства чтения, чтобы вам легче было считать знаки. Lua никаких пробелов в числах не потерпит.\n   Теперь перейдём к записи малых величин. Как я уже сказал, числа модуль которых больше одной десятитысячной (0,000 1) записываются как обычно. При этом, значащих цифр может быть также только четырнадцать. Если вы запишите больше, число будет округлено.\n\n   0.000 135 234 231 123 78\n   0.001 362 463 273 263 7\n   0.024 273 364 263 263\n   0.263 364 363 264 63\n   1.364 263 264 297 1\n\n   Если записываемое вами число меньше одной десятитысячной, оно автоматически переводится в экспоненциальную запись.\n   Число 0.000 099 9 будет выглядеть так: 9.999e-5. Знак минуса свидетельствует о том, что теперь число 10 возводится в отрицательную степень. То есть, теперь мы сдвигаем десятичную точку на указанное число позиций не вправо, а влево.\n   Конвертация из обычной записи в экспоненциальную и наоборот производится Lua автоматически. То есть, если вы записали в экспоненциальном виде число, лежащее в диапазоне, не требующем экспоненциальной записи, оно будет переведено в обычную запись.\n\n   1.23e<plus>4 —> 12300\n   3.67e-3 —> 0.00367\n\n   Буква \"e\" в экспоненциальной записи должна быть латинской, иначе программа выдаст ошибку. Знак плюса для экспоненциальной записи является необязательным, хотя сама программа его пишет всегда. Вы вполне можете использовать такую запись: 1.23e15. Программа отобразит это число с плюсом: 1.23e<plus>15.\n   А вот если вы попробуете сделать экспоненциальную запись с плюсом, то проверялка Lua, работающая при сохранении ответа, почему-то сообщит об ошибке. Вы можете не обращать на это никакого внимания и сохранять квест на сервер. При его работе никаких ошибок не возникнет.\n   Замечу также, что правильная (нормализованная) экспоненциальная запись предполагает, что модуль числа перед буквой \"e\" обязательно должен быть не меньше 1 и меньше 10. Впрочем, вам об этом можно не беспокоиться: если вы не соблюдёте это правило, программа автоматически вас поправит.\n   Например, число, записанное вами как 12.23e<plus>15, примет такой вид: 1.223e<plus>16.\n\n   String — строка.\n   Строка — это любая последовательность символов, размером от пустой строки (\"\") до текста любого объёма, который сможет осилить память вашего устройства. Вы запросто можете представить в виде строки полное собрание сочинений Фёдора Михайловича Достоевского.\n   Если вам это что-то скажет, Lua прекрасно работает с Юникодом и имеет для этих целей отдельную библиотеку.\n   Строковые литералы, то есть, текст, который вы вводите непосредственно в Lua-коде вашего квеста, ограничиваются парой обычных двойных (\"текст\") или одинарных ('текст') кавычек.\n   Так будет выглядеть присвоение переменной var строкового значения:\n\n   var = \"строковое значение\"\n\n   или так:\n\n   var = 'строковое значение'\n\n   Обе записи эквивалентны друг другу.\n   Почему используются два вида кавычек? На это есть своя причина. Что, если вам внутри строкового литерала понадобится записать слово в кавычках?\n\n    var = \"Пароход \"Карпатия\" на тот момент был ближайшим к \"Титанику\".\"\n\n   Если сделать такую запись, ничего путного не получится. Программа будет рассматривать в качестве строкового литерала только \"Пароход \", а всё остальное для неё будет выглядеть как полная абракадабра, никоим образом не вписывающаяся в концепцию того, как должен выглядеть правильный код. Вылезет сообщение об ошибке, после чего приложение спокойненько вылетит.\n   Но мы можем записать то же самое в одинарных кавычках и строковой литерал будет вполне корректно воспринят программой.\n\n   var = 'Пароход \"Карпатия\" в тот момент был ближайшим к \"Титанику\".'\n\n   А если вам требуется записать текст с апострофом, можно поступить наоборот:\n\n   var = \"Рассказы О'Генри отличаются своеобразным тонким юмором.\"\n\n   А что делать, если в стороковом литерале встречаются одновременно и кавычки, и апострофы? В этом случае вы можете использовать так называемые экранированные последовательности, которые записываются через обратный слеш: <s><s>\" и <s><s>'.\n\n   var = \"Издательство O'Reilly выпустило серию учебников <s><s>\"Head First<s><s>\", позволяющих даже новичкам с лёгкостью осваивать серьёзные языки программирования.\"\n\n   var = 'Издательство O<s><s>'Reilly выпустило серию учебников \"Head First\", позволяющих даже новичкам с лёгкостью осваивать серьёзные языки программирования.'\n\n   Вам может пригодиться ещё одна экранированная последовательность: если текст состоит не из одного абзаца, в нём должен быть перенос строки. Это реализуется посредством такой записи: <s>\n.\n\n   var = \"Я помню чудное мгновенье:<s>\nПередо мной явилась ты,<s>\nКак мимолётное виденье,<s>\nКак гений чистой красоты!\"\n\n   При отображении переменной var на ответе мы получим классические четыре строки стихотворного текста.\n\n   «Всё это, конечно, хорошо, но, ежли ты, говоришь, что можно в одном литерале записать хоть полное собрание Достоевского, не слишком ли много мороки возникнет с расстановкой обратных слешей?» — возможно, спросит кто-то из вас.\n   Но я отвечу, что и здесь Lua оказался на высоте. Если текст слишком велик, и вы хотите вставить его копипастом как он есть, вам доступен такой инструмент как «длинные строки». Любой текстовой литерал, ограниченный вместо кавычек двойными квадратными скобками, будет скушан программой на ура со всеми кавычками, переносами и вообще, всем чем угодно.\n\n   var = [[ <div>\n   <p>Вы можете сохранить в переменной вообще всё, что вам заблагорассудится. Мне заблагорассудилось продемонстрировать вам это на примере html-кода.</p>\n   <p>Вот так вот!</p>\n   <p>Круто ведь?!</p>\n   </div>]]\n\n   Если я пожелаю вывести содержимое переменной var на ответ (думаю, вы помните, как это сделать, из предыдущих уроков), мы увидим на нём именно такой текст. Без изменений.\n   Бывают случаи, когда в строковом литерале тоже могут встретиться двойные квадратные скобки. Например, это может случиться, если текст посвящён программированию и вы даёте там примеры кода, где идёт работа с массивами или таблицами. При их индексации также применяются квадратные скобки. Если один массив индексируется значением элемента другого массива, то в вашем текстовом литерале, посвященном этой теме, может встретиться, например, такая запись.\n\n   var = massive1[massive2[3]]\n\n   Заметили, что после тройки здесь идут двойные квадратные скобки? Они станут причиной того, что текстовой литерал, записанный длинной строкой, здесь завершится, что, естественно, приведёт к ошибке, так как последующий текст программа попытается рассмотреть в качестве исполняемого кода на Lua.\n   Но не волнуйтесь, эта проблема легко решаема. Если вы предполагаете, что где-то в тексте могут встретиться двойные квадратные скобки, просто добавьте любое количество знаков «равно» между открывающей и закрывающей парой квадратных скобок.\n\n   var = [===[Пример текста, посвященного работе с массивами:\n   var = massive1[massive2[3]]]===]\n\n   В этом примере сигналом окончания строкового литерала, записанного длинной строкой, послужит комбинация ]===]. При этом не важно, сколько перед ней будет квадратных скобок.\n   Но будьте внимательны: количество знаков «равно» между открывающими литерал квадратными скобками и закрывающими должно быть одинаковым. Иначе программа просто их проигнорирует и будет считать строковым литералом весь оставшийся код. Нетрудно догадаться, что это снова приведёт к ошибке.\n   Такая особенность функционала по работе с длинными строками открывает замечательные возможности по закомментированию больших фрагментов кода, о чём мы в своё время обязательно поговорим.\n   Обращу также ваше внимание на то, что внутри длинных строк никакие экранированные последовательности не работают. Они будут выглядеть так, как вы их записали.",
    "answers": [
      {
        "id": 21,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 10,
    "text": "   Сейчас вы выдите виджет, в котором написан \"свой\" текст: 《Монет:》 и значение переменной. \n   Когда идет настройка в режиме автора, то там будет написано: \"Для читателя\", и это означает, что виджет настроен на работу с авторским \"своим\" текстом. В режиме читателя же будет всё как прописано в функции.\n   Чтобы виджет существовал и его можно было использовать — создаём его:\n   \n   widget init [\"w1\", \"http://188.120.236.127/hc/island/lopata.png\", \"text\"]\n\n   Виджет \"w1\" создан и может быть использован. \n   w1 — имя виджета (вы можете использовать своё обозначение), ссылка должна быть прямой (оканчиваться расширением файла, например .png), \n   text — тот текст, что был бы отображен на стандартной записи виджета (его впринципе можно не трогать, ведь он будет заменен). \n   Выводим его как обычный виджет:\n\n   widget show [\"w1\", \"\"] \n   \n   А вот так выглядит написанный код для изменения текста виджета:\n   \n   function lua_do()\n       g[\"lua_text_widget\".. \"w1\"] = [[lua_text_widget = function() \n           return \"Монет: \" .. gold \n       end]] \n   end\n\n   Теперь пояснения:\n— \"w1\" — имя виджета (вы его вводили в widget_init, поэтому пишите тот, что вводили),\n— return \"Монет: \" .. gold — прописанный текст, который заменит стандартный текст виджета (обязательно в кавычках, иначе Луа не примет его как текст):\n      return — стандартная конструкция, не меняется, \n      \"Монет: \" — свободный текст по желанию автора; можно замерить на любой желаемый, но обязательно остаётся в кавычках,\n      .. gold — две точки присоединяют к тексту значение переменной gold, но вы, как автор, можете использовать там свою переменную; имя переменной лучше писать без кавычек, так как Луа может посчитать их за текст, и на выводе текст получится следующим: \"Монет: gold\". ",
    "answers": [
      {
        "super_calculate": false,
        "id": 10,
        "calculate": true,
        "widget_show": [
          "w1",
          "var"
        ],
        "text": " "
      },
      {
        "id": 6,
        "text": "Назад, к теории"
      },
      {
        "id": 11,
        "text": "Далее, к функции нажатия виджета",
        "lua_do": "function lua_do()\n    g[\"lua_tap\".. \"w1\"] = [[lua_tap = function() \n        gold = gold <plus> 5 \n        showPage { id = g.current_id, transition = \"instant\" }\n    end]]\nend"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 11,
    "text": "   Чтобы при нажатии на виджет выполнялся произвольный код — используем:\n\n   ",
    "answers": [
      {
        "id": 11,
        "text": "   function lua_do()\n       g[\"lua_tap\".. \"w1\"] = [[lua_tap = function() \n           gold = gold <plus> 5 \n           showPage{ id = g.current_id, transition = \"instant\" }\n       end]]\n   end\n\n   Теперь пояснения: \n— \"w1\" — имя вашего виджета, вписанное в widget_init, \n— gold = gold <plus> 5 — тут может быть любой авторский код (<plus> к здоровью и — к количеству, если виджет будет аптечкой или зельем здоровья; <plus> к добыче каких-либо материалов, если виджет является шахтой; <plus> к количеству патронов и — к деньгам, если виджет отображает определенный тип патронов, и этих типов представлено несколько...), \n— showPage { id = g.current_id, ...} - конструкция, которая совершает переход на текущую страницу, обновляя её (без неё невозможно отобразить реальное значение, измененное нажатием на виджет); \n- transition = \"instant\" - позволяет моментально отображать изменённое значение виджета (обязательно пишется внутри фигурных скобок в операторе showPage.\n   Если от нажатия виджета должна открыться другая страница, то нужно изменить на showPage { id = 5 }, и тогда при нажатии на виджет откроется тот номер страницы, что вписан в фигурных скобках (таким способом можно создать переход в инвентарь, но стоит сразу задуматься о способе возврата из этого инвентаря).\n   Чтобы все виджеты приняли новые функции их нужно писать в ответе с calculate, или на ответах, которые предшествуют появлению виджетов.\n\n   Сейчас предлагаю вам нажать на виджет и увидеть как он срабатывает с отрисовкой на текущую страницу.",
        "widget_show": [
          "w1",
          "var"
        ],
        "merge": true
      },
      {
        "id": 10,
        "text": "Назад, к замене текста на виджете"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 12,
    "text": "   Lua (лу́а, с порт. — «луна») — скриптовый язык программирования, разработанный в подразделении Tecgraf (Computer Graphics Technology Group) Католического университета Рио-де-Жанейро (Бразилия).\n   Этот язык уникален по своей универсальности и гибкости, прост в изучении, так как изначально рассчитывался на непрофессиональных программистов. \n   Главная его фишка — решение задач универсальными средствами, в то время как в других языках для этого создаётся отдельный функционал. В этом он не знает себе равных.",
    "answers": [
      {
        "id": 13,
        "text": "Требования к наименованию переменных"
      },
      {
        "id": 14,
        "text": "Рекомендации к именам переменных"
      },
      {
        "id": 15,
        "text": "Операторы и что они делают"
      },
      {
        "id": 16,
        "text": "Функции и что они делают"
      },
      {
        "id": 17,
        "text": "Функция lua_do"
      },
      {
        "id": 18,
        "text": "Функция lua_if"
      },
      {
        "id": 19,
        "text": "Функция lua_text"
      },
      {
        "id": 20,
        "text": "Запись кода в lua_do, lua_if и lua_text "
      },
      {
        "id": 9,
        "text": "Типы данных"
      },
      {
        "id": 21,
        "text": "Таблицы"
      },
      {
        "id": 40,
        "text": "Объекты"
      },
      {
        "id": 12,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 13,
    "text": "   К именам переменных Луа предъявляет определённые требования. Нарушение их непременно приведёт к серъёзным ошибкам, а возможно и к вылету приложения.\n\n  Вот эти требования:\n\n— в именах переменных можно использовать только буквы латиницы, и знак подчёркивания _ (дефисы и пробелы запрещены),\n— имя переменной не может начинаться с цифры,\n— нельзя использовать в качестве имён переменных зарезервированные слова (and, break, do, else, elseif, end, false, for, function, goto, if, in, local, nil, not, or, repeat, return, then, true, until, while).",
    "answers": [
      {
        "id": 14,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 14,
    "text": "   Есть несколько рекомендаций по выбору имён переменных. Они необязательны для соблюдения, но могут упростить вам жизнь при работе над квестом. Соблюдение этих рекомендаций является своего рода хорошим тоном в программировании.\n   Давайте переменным говорящие имена. Если вы знаете английский, лучше на нём, если нет, то пользуйтесь транслитом (attack — ataka, damage — uron).\n   Начинайте имя переменной с маленькой буквы и, если оно состоит из нескольких слов, каждое, кроме первого, начинайте с большой буквы. При этом отпадёт нужда разделять слова символом подчёркивания для удобочитаемости (attackPerRound, firstEnemy, pervyProtivnik).\n   Используйте общепринятые имена для локальных переменных при организации циклов (i, j, k — для вложенных друг в друга циклов со счётчиком, key, val — для общего for при переборе значений таблиц).",
    "answers": [
      {
        "id": 15,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 15,
    "text": "   Операторы выполняют какое-то одно действие. Иными словами, в рамках одного оператора не может быть последовательных этапов.\n   Самый распространённый оператор — присваивание. Он обозначается знаком «равно».\n   \n   a = b — 1\n\n   Этот оператор говорит программе, что переменной «a» нужно присвоить значение переменной «b», из которой вычтена единица.    \n   Особенностью этого оператора является то, что переменной, стоящей перед знаком «равно» присваивается результат всего выражения, стоящего после, каким бы сложным оно ни было. До тех пор, пока выражение не рассчитано полностью, значение переменной слева от «равно» не изменится.\n\n   Такая особенность подхода к операции присваивания позволяет нам выполнять следующую запись:\n\n   a = a <plus> 1\n\n   Если «a» равно 10, то после этой операции оно станет равным 11.\n\n   a = a * 2 / (a — 4)\n\n   При том же значении результатом этой операции станет значение «a», равное 3.(3) (три целых и три в периоде). И это по-прежнему всего лишь одна операция, а переменная «a» на протяжении всего процесса вычисления сохраняет своё изначальное значение.\n\n   Операторы могут быть гораздо более сложными, но это не отменяет того факта, что они выполняют ОДНО действие, одну операцию.",
    "answers": [
      {
        "id": 16,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 16,
    "text": "   Функции это обособленные участки кода, которые выполняются только при их вызове. Они могут быть описаны заранее с присвоением имени, посредством которого в любом месте программы их можно вызывать любое количество раз. При вызове функции ей могут передаваться данные. Также она в качестве результата своей работы может возвращать данные, которые можно присвоить переменным.\n   Можно привести такую аналогию. Вы — руководитель предприятия. У вас есть сотрудник, который хорошо умеет заключать договора с партнёрами. Пока вам не нужно заключать договор, это сотрудник вас не интересует. Как только такая нужда возникла, вы вызываете его, передаёте ему данные по договору, который нужно заключить, и после этого уже занимаетесь своими делами, ожидая результата.\n   Выполнив работу, сотрудник отчитывается перед вами о проделанной работе, сообщает, был ли подписан договор или нет, рассказывает об изменении условий — выгодах, которых удалось добиться, или уступках, на которые пришлось пойти.\n   Данные, которые передаются функции, называются аргументами, внутри же самой функции они называются параметрами. Сложно немного, но это надо запомнить. При передаче они — аргументы, после передачи (получения) — параметры.\n   Рассмотрим, как объявляется функция в Lua.\n\n   function nameOfFunction(param1, param2, param3)\n       local result = 0\n       код функции, вычисляющий некоторое значение на основе переданных аргументов и записывающий его в переменную result\n       return result\n   end\n\n   function — ключевое слово, сообщающее Lua, что дальше будет описана функция.\n   nameOfFunction — любое имя-идентификатор, соответствующее правилам имён переменных, изложенным в предыдущем уроке. Это имя будет использоваться для вызова функции.\n   param1, param2, param3 — параметры функции. Их может быть любое количество, а может и не быть совсем — в этом случае скобки остаются пустыми — (). Параметры рассматриваются функцией как локальные переменные — они существуют лишь в пределах функции. По окончании её работы они уничтожаются. Имена параметров также могут быть любыми, если они соответствуют правилам имён переменных.\n   local — ключевое слово, которое используется для объявления локальных переменных. Такие переменные существуют только в пределах функции, в которой были объявлены.\n   result — локальная переменная, используемая для хранения результата вычислений.\n   return — оператор, позволяющий возвращать из функции результаты её работы. Значение переменной result будет передано программе, вызвавшей функцию. Этот оператор должен идти последним внутри функции. Всё, что идёт после него, обрабатываться не будет.\n   end — ключевое слово, сигнализирующее об окончании блока. Все блоки в Lua должны заканчиваться этим словом. Под блоками подразумевается функционально выделенные участки кода — функции, управляющие условные конструкции, циклы и др. Понятие блока очень важно, так как локальные переменные (и не только переменные) существуют лишь в пределах блока, в котором они объявлены.\n   Объявленная функция ещё не выполняется программой. Чтобы она выполнилась, её нужно вызвать: сотрудник, умеющий заключать договора, будет заключать их лишь тогда, когда вы ему это поручите.\n   Вызов функции может быть выполнен в любой части программы после её объявления. Вызов до объявления приведёт к ошибке. Вызов производится очень просто:\n\n   a = nameOfFunction(20, \"текстовой аргумент\", var1)\n\n   Что здесь происходит. Вызывается объявленная нами ранее функция и ей в качестве аргументов передаётcя число, строка (текст) и значение переменной. Таким образом параметр param1 станет равным 20, param2 примет значение \"текстовой аргумент\", а param3 примет значение переменной var1.\n   На протяжении работы этого вызова функции они будут иметь именно эти значения. При другом вызове аргументы могут быть другими и параметры, соответственно, тоже будут другими.\n   После того как функция завершит свою работу, переменная \"a\" станет равной значению локальной переменной result, которая была вычислена в процессе работы данного вызова функции.",
    "answers": [
      {
        "id": 17,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 17,
    "text": "   Эта функция является главным вычислительным инструментом приложения. Для её использования в поле редактирования ответа нужно записать следующий текст:\n\n   function lua_do()\n       любой код на Lua\n   end\n\n   Как вы уже, наверное, догадались, это ни что иное как объявление функции. Вызов её будет произведён самим приложением при нажатии на ответ.\n   Если вам неудобно набирать, то с включенным Продвинутым режимом под полем редактирования ответа есть кнопка, которая наберёт за вас первую и последнюю строчки. Код же придётся писать самому…\n   Что делает эта функция? При нажатии на ответ она выполняет любой код на Lua, записанный внутри неё. Либо это делается автоматически при загрузке страницы, если ответ является калькулейтом (calculate). Она не получает аргументов и не возвращает никаких значений, но имеет доступ ко всем переменным квеста.",
    "answers": [
      {
        "id": 18,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 18,
    "text": "   С этой функцией не всё так просто, как с lua_do и lua_text. Записывается она аналогичным образом.\n\n   function lua_if()\n       код функции\n       return результат вычислений\n   end\n\n   Помните, мы говорили о том, что функции могут возвращать значения как результат своей работы? Для этого используется оператор return, который должен стоять в самом конце функции.\n   Так вот, если функция возвратит какое-либо значение, кроме false или nil, ответ, на котором она размещена, отобразится. В противном случае читатель его не увидит.\n   Отвлечёмся немного и поговорим о упомянутых специфических значениях.\n   false — это одно из двух так называемых булевых значений, означающее ложь. Другое значение — true — это истина.\n   Булевых значений может быть только два. Их можно сравнить с переключателем — он либо включен, либо нет.\n   Так вот, если в результате работы кода, расположенного внутри вашей функции lua_if, оператор return вернёт значение false, ответ не будет отображён. Если он вернёт любое другое значение, будь-то строка, число, таблица, функция или булево значение true, ответ будет отображён. Тем, кто программировал на Basic, важно знать, что, даже если будет возвращён ноль, Lua будет считать его булевым значением true и ответ отобразится.\n   Еще раз, чтобы запомнили: Lua приравнивает к значению true (истина) любое значение, кроме false (ложь). И кроме ещё одного очень специфического значения — nil.\n    Оно интересно тем, что, по сути, значением как таковым не является. Nil — это отсутствие всякого значения. Оно во многом странно и парадоксально, но сейчас мы об этом говорить не будем. Сейчас нам достаточно запомнить, что nil — это ничто. И Lua приравнивает его к false при выполнении логических операций, результатом которых должно быть булево значение.\n   Если вы, например, забудете в конце какой-либо из функций поставить оператор return, то она ничего не вернёт. То есть вернёт значение nil. Это как в английском языке nobody came. Если переводить совсем уж буквально, можно сказать: «пришёл никто».\n   Если вы забудете поставить return в конце функции lua_if, она также ничего не вернёт (вернёт nil) и ответ не будет отображён ни при каких обстоятельствах. Потому что, как мы уже сказали, Lua приравнивает nil к значению false.\n   Особенностью функции lua_if является то, что она в отличие от lua_do рассчитывается ещё до отрисовки страницы. Это и понятно: ведь программе нужно знать, отображать ответ или нет. В этом отношении она похожа на калькулейт (calculate).\n   Упомянутая особенность при неправильном использовании может привести к неожиданным последствиям. Поэтому будьте внимательны и помещайте внутрь этой функции только то, что действительно необходимо для принятия решения об отображении ответа. Не стоит изменять значения каких-либо данных, расположенных вне этой функции, если вы не знаете точно, что делаете.",
    "answers": [
      {
        "id": 19,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 19,
    "text": "   С этой функцией всё намного проще. Всё, что она делает — отображает на ответе текст, который был возвращён в результате её работы. Этот текст перекроет то, что написано на ответе при его редактировании. И точно также перекроет работу квестового оператора var show.\n   Записывается эта функция следующим образом:\n\n   function lua_text()\n       return переменная с результатом работы функции\n   end\n\n   Переменная должна содержать текст или число.\n   Эта функция, так же как и lua_if, выполняется до отрисовки страницы. И она также требует осторожного отношения: записывайте в неё только то, что действительно необходимо для формирования текста ответа.\n   Обратите внимание, что результат работы этой функции виден исключительно в режиме читателя. Поэтому в авторском режиме на ответе будет отображаться его «родной» текст, а также результат работы оператора var show. В режиме читателя всё это будет затёрто результатом работы функции lua_text.\n   Обратите внимание: если выйдет так, что этим результатом окажется nil (функция ничего не вернёт), то на ответе отобразится его родной текст и результат работы оператора var show при его наличии. Иногда это может оказаться полезным.",
    "answers": [
      {
        "id": 20,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 20,
    "text": "   В «Текстовых квестах» код Lua может быть включён в квест тремя способами. Это функции lua_do, lua_if или lua_text.\n   Внутри этих функций теоретически может быть записан код любой сложности и величины. Практически ограничения накладывают объём памяти устройства и продолжительность обработки кода одного ответа при сохранении. \n    Например, ответ, код которого содержит около 10 000 символов будет сохраняться где-то 20 секунд. Соответственно, если код будет в десятки и сотни раз больше, время сохранения ответа превысит все мыслимые рамки.\n   Из чего, собственно, состоит код? Из последовательно расположенных друг за другом операторов или команд, к числу которых могут принадлежать управляющие конструкции, в зависимости от тех или иных факторов изменяющие последовательность выполнения программы.\n   Простейшим и наиболее широко используемым является оператор присваивания, обозначаемый знаком «равно». Он присваивает переменной, расположенной слева от знака значение выражения, расположенного справа.\n\n   a = b * 3\n\n   Переменная «a» после выполнения этого оператора станет равной значению переменной «b», умноженному на 3. Чтобы всё это заработало у нас в квестах, нужно на ответе выполнить следующую запись:\n\n   function lua_do()\n       a = b * 3\n   end\n\n   Элементарно, не так ли? Отступы в записи используются лишь для удобочитаемости кода. Дело в том, что в коде много конструкций, которые вложены друг в друга наподобие матрёшек. Если не делать отступов, в коде будет очень сложно разобраться.\n   На самом деле Lua полностью игнорирует как лишние пробелы, так и переносы строк. Для него они как бы не существуют.\n   Как же тогда разделять операторы между собой, спросите вы? Пробелами, переносами строк и точкой с запятой. Однако по поводу последней я должен предупредить, что использовать её в конце строки крайне опасно.\n   Связано это с тем, что наши разработчики реализовали в приложении удобный способ, позволяющий заполнять ответы не по одному квестовому оператору, а одним махом. Это удобно, если вы пишите код в отдельном текстовом редакторе, а потом вставляете его в квест.\n   Если мы завершаем строку точкой с запятой и сразу за ней идет перенос строки, приложение расценит такую запись как переход к следующему оператору.\n   Например, мы можем заполнить ответ одним махом, введя такой текст.\n\n   Это текст ответа.;\n   !23;\n   ?11;\n   #6;\n   calculate;\n   var equal[\"i\", 2];\n   var set [\"var1\", 23];\n   var add [\"var2\", 1]\n\n   Представляете, к какому хаосу приведёт ситуация, если из-за точки запятой, разделяющей операторы Lua, программа завершит ввод блока lua_do и попытается занести оставшийся код в качестве следующего оператора?\n   Поэтому чётко придерживаемся правила: в конце строки Lua-кода точки с запятой не должно быть никогда.\n   Мы вполне можем использовать такую запись:\n\n   function lua_do()\n       a = b * 3; c = c — 1\n   end\n\n   Но не такую:\n\n   function lua_do()\n       a = b * 3;\n       c = c — 1\n   end\n\n   Такая запись приведёт к ошибке.\n   На самом деле мы можем спокойно использовать в качестве разделителя операторов, идущих в одну строку, и обыкновенный пробел. Lua не будет иметь ничего против такой записи:\n\n   function lua_do()\n       a = b * 3 c = c — 1\n   end\n\n   Но это визуально выглядит грязно, и подобная запись является дурным тоном в программировании. Многие программисты придерживаются правила записывать не более одного оператора в строке.",
    "answers": [
      {
        "id": 9,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 21,
    "text": "   Это особый тип данных, непохожий на остальные и представляющий собой ассоциативные массивы.\n   ",
    "answers": [
      {
        "id": 21,
        "text": "   Во-первых, рассмотрим понятие массива. Что это такое? По сути своей, это набор переменных, объединённых одним именем. Чтобы было понятно, приведу аналогию.\n   Допустим, вы житель дома №14 по улице имени 50 лет Последних черепаших боёв. Допустим, вас зовут Вася Чунгачангин. Ваше имя будет храниться у нас в переменной greatHero. Итак присваиваем:\n\n   greatHero = \"Вася Чунгачангин\"\n\n   Теперь мы можем обращаться к этой переменной, чтобы узнать ваше имя. Но проблема в том, что иногда нам очень неудобно создавать отдельную переменную для каждой записи данных. Мало того, иногда нам нужно объединить некоторое количество данных в общность, к которой мы могли бы обращаться по одному имени.\n   Допустим, нам нужно объединить всех жильцов дома №14 по улице 50 лет Последних черепашьих боёв в некую общность, чтобы мы могли по одному принципу обращаться ко всем жильцам и в любой момент узнать имя каждого из них.\n   Для этого и нужен массив. Заметьте, пока у нас речь идёт только об обычном массиве — не об ассоциированном.\n   Что мы делаем? Мы создаём одну переменную под именем zhiltsy и присваиваем ей вместо значения одного из изученных прежде типов так называемый конструктор таблицы. Конструктор заключается в фигурные скобки и в простейшем случае может не содержать вообще ничего:\n\n   zhiltsy = {}\n\n   Такая запись создаст пустой массив и присвоит ссылку на него переменной zhiltsy. Если в этой переменной прежде хранились данные, в том числе массив, они будут удалены.\n",
        "merge": true
      },
      {
        "id": 21,
        "text": "   Теперь внимание! Это крайне важный момент: присвоит ссылку!  Здесь заключена принципиальная разница между таблицами и другими типами данных, о которых мы уже говорили. Таблица — это не значение. Это объект!!! А объект нельзя присвоить, на него можно только указать, сослаться.\n   Я, например, могу выучить наизусть всего «Евгения Онегина». Это значение, а я выступаю в качестве переменной, которой это значение присваивается. Но если бы существовал такой реальный человек — Евгений Онегин, я при всём желании не смог бы присвоить его в качестве значения, потому что он являлся бы объектом реального мира, а не набором данных.\n   Я могу только лишь указывать на него. Я становлюсь ссылкой на объект.\n   В чём принципиальная разница? Она огромна и заключается вот в чём: две переменные с одинаковым значением никак не связаны между собой, изменение значения одной переменной не повлечёт за собой изменения значения другой. Потому что речь идёт о данных, записанных в саму переменную.\n   Но если речь идёт об объекте, все изменения в нём, сделанные посредством доступа по ссылке, записанной в переменной, будут объективны. То есть, все переменные ссылающиеся на этот объект будут при обращении к ним выдавать изменённые данные.\n   Если я пошлю парикмахера к Евгению Онегину и тот сбреет ему бакенбарды, все другие знакомые Евгения, отсылая кого-то к нему, будут отсылать их уже к человеку без бакенбардов.\n   Повторяю! Эту принципиальную разницу между значениями и объектами крайне важно понять. Если не поняли, перечитайте ещё раз. Иначе, когда мы двинемся дальше, каша в голове будет только нарастать.\n",
        "merge": true
      },
      {
        "id": 21,
        "text": "   Так вот, массивы в Lua — это всегда и исключительно объекты.\n   Давайте приведём пример непустого массива, созданного с помощью конструктора:\n\n   zhiltsy = {\"Вася Чунгачангин\", \"Петя Мумбаюмбин\", \"Женя Ширлимырлин\", \"Галя Траливалина\", \"Лена Чикчирикина\"}\n\n   Вы видите перед собой обычный неассоциированный массив. Хотя на самом деле обычный неассоциированный массив в Lua является частным случаем ассоциированного.\n   Обычный массив подразумевает автоматическую нумерацию элементов, начинающуюся с 1. Каждому жильцу в этом массиве присвоен свой порядковый номер:\n\n",
        "merge": true
      },
      {
        "id": 21,
        "text": "   1. Вася Чунгачангин.\n   2. Петя Мумбаюмбин.\n   3. Женя Ширлимырлин.\n   4. Галя Траливалина.\n   5. Лена Чикчирикина.\n\n   Теперь мы в любой момент можем получить доступ к имени жильца, индексируя таблицу (массив):\n\n   womanHero = zhiltsy[5]\n\n   Теперь переменная womanHero примет значение \"Лена Чикчирикина\". И это будет именно значение, а не ссылка на объект. Потому что ей присваивается не таблица (массив), а значение, записанное в её поле.\n   Поле таблицы может содержать значение любого типа, в том числе и ссылку на другую таблицу.\n   А теперь друзья, возможно, вас ждёт настоящее откровение. Приготовьтесь! У нас в «Квестах» нет переменных! Ни единой! Всё, что мы условно называли до этого переменными, на самом деле поля таблиц. Обычные переменные квеста содержаться в полях таблицы, на которую ведёт ссылка «переменной» vars (и это блин тоже поле таблицы верхнего уровня!). А все глобальные переменные хранятся в «переменной» global_vars.\n   Теперь, правда, разработчики немного упростили нам задачу: vars можно опустить при обращении к переменной, а вместо global_vars достаточно написать буковку g с точкой.\n   Теперь пришла пора поговорить об ассоциированных массивах. В чем разница? В том, что вместо порядковых номеров в массиве можно использовать текстовые значения. Да и не только текстовые. По сути — любого типа, кроме nil. Но мы ограничимся текстовыми. Допустим, нам надо сохранить не сами имена жильцов (они нам и так известны, и мы будем использовать их в качестве ключа), а их долги по ЖКХ.\n",
        "merge": true
      },
      {
        "id": 21,
        "text": "   Записываем:\n\n   dolgiZhiltsov = {[\"Вася Чунгачангин\"] = 3000, [\"Петя Мумбаюмбин\"] = 5000, [\"Женя Ширлимырлин\"] = 45000, [\"Галя Траливалина\"] = 0, [\"Лена Чикчирикина\"] = -53000}\n\n   Похоже, Лена Чикчирикина — коллектор, скупивший все долги своих соседей. Серьёзная дама!..\n   Если при записи текстовых ключей использовать квадратные скобки и кавычки, они могут содержать любые символы, но если привести их в соответствие с правилами записи идентификаторов, о которых мы говорили в одном из предыдущих уроков, запись можно значительно упростить.\n\n   dolgiZhiltsov = {Vasya_Chungachangin = 3000, Petya_Mumbayumbin = 5000, Zhenya_Shirlimyrlin = 45000, Galya_Tralivalina = 0, Lena_Chikchirikina = -53000}\n\n   Как видите, квадратные скобки на пару с кавычками ушли в небытие.\n   Ещё раз напомню правила записи идентификаторов: только цифры, символы латиницы и подчёркивания, при этом идентификатор не начинается с цифры. Никаких дефисов и пробелов. Никаких символов помимо перечисленных.\n   Таким образом мы с вами получили классический ассоциативный массив или таблицу.\n   Несколько слов об индексировании таблиц. Обычные массивы индексируются только цифрами, заключёнными в квадратные скобки:\n\n  zhiltzy[3]\n\n   Ассоциативные массивы индексируются либо текстом, заключённым в кавычки и в квадратные скобки (этим способом можно индексировать и посредством идентификаторов, полностью соответствующих правилам), либо записью идентификатора через точку:\n\n   dolgVasi = dolgiZhiltsov[\"Вася Чунгачангин\"]\n   dolgZheni = dolgiZhiltsov.Zhenya_Shirlimyrlin\n\n   При втором способе идентификатор должен полностью соответствовать правилам.\n   Естественно, доступ к полю таблицы посредством индексации может использоваться не только для чтения. Представим, что Лена-коллектор влюбилась в Васю и простила ему долг.\n\n   dolgiZhiltsov.Vasya_Chungachangin = 0\n\n   Если вы хотите использовать переменную для индексации массива, просто впишите её имя в квадратные скобки:\n\n   dolgiZhiltsov[imyaZhiltsa] = 0\n\n   И напоследок. Как я уже сказал, в поле таблицы, подобно матрёшке, может вкладываться конструктор другой таблицы. И так до бесконечности.\n\n   tablitsa = {uroven1 = {uroven2 = {uroven3 = \"Значение\"}, uroven2_2 = {uroven3 = \"Значение\"}}, uroven1_2 = \"Еще одна таблица или что-то другое\"}\n\n   Также точно можно присвоить таблицу и через индексацию:\n\n   dolgiZhiltsov.Vasya_Chungachangin = {dolgPeredSosedyami = 0, dolgPeredBankom = 1000000, dolgPeredGosudarstvom = {voennyyDolg = \"1 год срочной службы\", grazhdanskyyDolg = \"Not defined\"}}\n\n   Как видите, одна и та же таблица может преспокойно содержать значения различных типов.",
        "merge": true
      },
      {
        "id": 40,
        "text": "Перейти к следующему уроку"
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 22,
    "text": "    ",
    "answers": [
      {
        "super_calculate": true,
        "lua_do": "function lua_do()\n  function g.findInText(text, word, page)\n    word = utf8.gsub(word, \"([%(%)%.%%%<plus>%-%*%?%[%]%^%$])\", \"%%%0\")\n    local start, finish = utf8.find(text, word)\n    if start then\n      local result\n      result = \n  utf8.match(text, \"^[^<s>\n]-\".. word.. \"[^<s>\n]-$\") or\n  utf8.match(text, \"^[^<s>\n]-\".. word.. \"[^<s>\n]-<s>\n\") or\n  utf8.match(text, \"<s>\n[^<s>\n]-\".. word.. \"[^<s>\n]-$\") or\n  utf8.match(text, \"<s>\n[^<s>\n]-\".. word.. \"[^<s>\n]-<s>\n\")\n      result = utf8.gsub(result, \"[%s<s>\n]<plus>\", \" \")\n      if #result > 100 then\n        result = utf8.sub(result, 1, 100)\n        if utf8.sub(result, 100, 100) == \" \" then\n          result = utf8.sub(result, 1, -2)\n        else\n          result = utf8.sub(result, 1, -2) .. \"...\"\n        end\n      end\n      table.insert(results, {text = result, \n      fontSize = 0.9, pressListener = \n      function() \n        showPage{id = page} \n        hideDialog() \n      end})\n      return true\n    end\n    return false\n  end\nend",
        "calculate": false,
        "text": "Поиск в тексте",
        "id": 23
      },
      {
        "comment": false,
        "super_calculate": true,
        "id": 23,
        "text": "Поиск",
        "calculate": false,
        "lua_do": "function lua_do()\ntimer.performWithDelay(1, function()\nlocal cw, ch = display.contentWidth, display.contentHeight\nlocal w = cw*0.1\nlocal find = display.newImage(canvas.parent.parent.parent.parent.parent, \"detective-md.png\", 0, 0)\nfind.xScale = w/find.width\nfind.yScale = find.xScale\nfind.x = cw - find.contentWidth/2 - 0.04*cw\nfind.y = find.contentHeight/2 <plus> 0.03*cw\nfind:setFillColor(0)\n\nfind:addEventListener(\"tap\",   \n  function(event)\n    if not event.target.input then\n      local cw, ch = display.contentWidth, display.contentHeight\n      local input = native.newTextField(cw*0.5, cw*0.07, cw*0.6, cw*0.075)\ncanvas.parent.parent.parent.parent.parent:insert(input)\n      event.target.input = input\n    else\n      local word = event.target.input.text or \"  \"\n      if utf8.match(word, \"^%s*$\") then\n        if event.target.input and event.target.input.removeSelf then\n          event.target.input: removeSelf()\n        end\n        event.target.input = nil\n        return true\n      end\n\n      results = {{text = \"Назад\", fontSize = 0.9}}\n      local findPages = 0\n      for i = 1, #pages do\n        local successFind\n        if g.findInText(pages[i].text, word, i) then\n          successFind = true\n        end \n        for j = 1, #pages[i].answers do\n          local answer = pages[i].answers[j]\n          if answer.comment and not (answer.calculate or answer.super_calculate) then\n            if g.findInText(answer.text, word, i) then\n              successFind = true\n            end\n          end\n        end\n        if successFind then\n          findPages = findPages <plus> 1\n        end\n        if #results >= 50 then\n          break\n        end\n      end\n      if event.target.input and event.target.input.removeSelf then\n        event.target.input:removeSelf()\n      end\n      event.target.input = nil\n      if #results <=1 then\n        message(\"Ничего не нашлось\")\n      else\n        dialog{header = 'Результаты поиска \"' .. word .. '\"',\n        text = \"Вхождений: \".. (#results - 1) .. \", страниц: \" .. findPages,\n        fontSizeForBody = 0.9,\n        answers = results}\n      end\n    end\n  return true\n  end)\nend)\nend"
      }
    ]
  },
  {
    "id": 23,
    "text": "   Конечно. \n\n   function lua_do()\n       x = math.random(5,10)\n       message(\"Вы получили подать \" .. x .. \" монет от богатого влиятельного человека.\")\n       gold = gold <plus> x\n   end\n\n   Опробуем этот код:",
    "answers": [
      {
        "id": 23,
        "text": "Сейчас у вас монет:",
        "comment": true,
        "var_show": [
          "gold"
        ]
      },
      {
        "id": 23,
        "text": "Просить подать у прохожих...",
        "comment": false,
        "lua_do": "function lua_do()\n    local x = math.random(5,10)\n    message(\"Вы получили подать \" .. x .. \" монет от богатого влиятельного человека.\")\n    gold = gold <plus> x\nend"
      },
      {
        "id": 23,
        "text": "   Тут мы видим, что рандом-значение \"х\" не только входит в состав текста message, но и участвует в расчётах. \n   Можно написать код и сложнее, но имейте в виду тот факт, что в message не срабатывает перенос строки \"<s>\n\".",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 24,
    "text": "   При сложных расчётах возникают нецелые числа, например 1.275, или 8.12255. Если эти значения использовать, то читаемость значений становится плохой, ведь появляется большой набор цифр.\n   \n   Здоровье: 76.56725 / 100\n   Мана: 25.56327895 / 100\n\n   Согласитесь, что такой вид не всем привлекателен, и именно поэтому стоит использовать округление.\n   Ниже представленны основные операторы округления.",
    "answers": [
      {
        "id": 25,
        "text": "math.floor",
        "var_set": [
          "abc",
          0
        ]
      },
      {
        "id": 26,
        "text": "math.round ",
        "var_set": [
          "abc",
          0
        ]
      },
      {
        "id": 27,
        "text": "math.ceil",
        "var_set": [
          "abc",
          0
        ]
      },
      {
        "id": 28,
        "text": "Округление, но с одним или двумя знаками после запятой",
        "var_set": [
          "abc",
          0
        ]
      },
      {
        "id": 24,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 25,
    "text": "   math.floor — округляет до целого числа в меньшую сторону, откидывая весь дробный остаток (например, 8.775 округлится до 8, или 9.995 округлится до 9).\n\n   function lua_do()\n       x = 10\n       y = 3\n       abc = math.floor (x / y)\n   end\n\n   В этом примере x / y = 10 / 3 = 3.(3), а math.floor округлит его, и значение аbc будет равно 3.\n   Вот пример посложнее:\n\n   function lua_do()\n       x = 10\n       y = 3\n       z = 1\n       abc = math.floor(((x^2 — z) * y) / ((y^2 — z) <plus> math.random(10)))\n   end\n\n   Не суть важно сколько в этом примере получится значении abc, ведь рандом будет влиять на конечный результат, а math.floor округлит до целого числа в меньшую сторону.\n   Посмотри как работает округление, использовав каждую кнопку по 3-5 раз.",
    "answers": [
      {
        "comment": false,
        "lua_do": "function lua_do()\n    x = 10\n    y = 3\n    z = 1\n    abc = math.floor(((x^2 - z) * y) / ((y^2 - z) <plus> math.random(10)))\nend",
        "text": "Сложная формула из последнего примера с округлением",
        "instant": true,
        "id": 25
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    x = 10\n    y = 3\n    z = 1\n    abc = ((x^2 - z) * y) / ((y^2 - z) <plus> math.random(10))\nend",
        "text": "Сложная формула из последнего примера без округления",
        "instant": true,
        "id": 25
      },
      {
        "id": 25,
        "text": "abc =",
        "comment": true,
        "var_show": [
          "abc"
        ]
      },
      {
        "id": 24,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 26,
    "text": "   math.round округляет до целого числа, но в зависимости от остатка дробной части выбирает в какую сторону округлять: в большую, или в меньшую.\n   Например, значение после расчета 9.75 округлит до 10, а значение 4.4 округлит до 4.\n   Всё, что будет до 0.5 — округляется в меньшую сторону, а при 0.5 и более округляет в большую сторону.",
    "answers": [
      {
        "comment": false,
        "id": 26,
        "text": "   function lua_do()\n       abc = math.round(10 / 4)\n   end\n\n   Получаемое значение от деления: 2.5",
        "lua_do": "function lua_do()\n    abc = math.round(10 / 4)\nend",
        "instant": true
      },
      {
        "comment": false,
        "id": 26,
        "text": "   function lua_do()\n       abc = math.round(10 / 4.5)\n   end\n\n   Получаемое значение от деления: 2.(2)",
        "lua_do": "function lua_do()\n    abc = math.round(10 / 4.5)\nend",
        "instant": true
      },
      {
        "comment": false,
        "id": 26,
        "text": "   function lua_do()\n       abc = math.round(10 / 3.5)\n   end\n\n   Получаемое значение от деления: 2.86",
        "lua_do": "function lua_do()\n    abc = math.round(10 / 3.5)\nend",
        "instant": true
      },
      {
        "id": 26,
        "text": "Округленное abc =",
        "comment": true,
        "var_show": [
          "abc"
        ]
      },
      {
        "id": 24,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 27,
    "text": "   math.ceil работает также как и math.floor, но округляет до целого числа в большую сторону.\n   Если значение в расчетах выйдет 9.6875, то после округления значение переменной станет равно 10. Если же значение после расчётов 5.125 — значение переменной будет равно 6.\n\n   function lua_do()\n       x = 10\n       y = 3 \n       abc = math.ceil (x / y)\n   end\n\n   Математически получается 10 / 3 = 3.(3), но math.ceil округлит до 4. Проверим? ",
    "answers": [
      {
        "comment": false,
        "id": 27,
        "text": "   function lua_do()\n       x = 10\n       y = 3 \n       abc = math.ceil(x / y)\n   end",
        "lua_do": "function lua_do()\n    x = 10\n    y = 3 \n    abc = math.ceil(x / y)\nend",
        "instant": true
      },
      {
        "id": 27,
        "text": "abc =",
        "comment": true,
        "var_show": [
          "abc"
        ]
      },
      {
        "id": 24,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 28,
    "text": "   Если нужно один или два знака после запятой, то нужно в операторе с округлением использовать умножение до округления и деление послп округления.",
    "answers": [
      {
        "comment": false,
        "id": 28,
        "text": "Без округления:\n   function lua_do()\n       abc = 12345 * 0.665\n   end",
        "lua_do": "function lua_do()\n    abc = 12345 * 0.665\nend",
        "instant": true
      },
      {
        "comment": false,
        "id": 28,
        "text": "С округлением:\n   function lua_do()\n       abc = math.round((12345 / 6.8) * 10 ) / 10\n   end",
        "lua_do": "function lua_do()\n    abc = math.round((12345 / 6.8) * 10 ) / 10\nend",
        "instant": true
      },
      {
        "comment": false,
        "id": 28,
        "text": "С округлением:\n   function lua_do()\n       abc = math.round((12345 / 4) * 100 ) / 100\n   end",
        "lua_do": "function lua_do()\n    abc = math.round((12345 / 4) * 100 ) / 100\nend",
        "instant": true
      },
      {
        "id": 28,
        "text": "Округленное abc =",
        "comment": true,
        "var_show": [
          "abc"
        ]
      },
      {
        "id": 28,
        "text": "  ",
        "comment": true
      },
      {
        "id": 24,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 29,
    "text": "   Для того, чтобы увеличить время отображения massage, можно использовать string.rep(\" \", число). Это повторит \" \" указанное количество раз. Из этого увеличится и время отображения.\n\n   message(\"Привет!\" .. string.rep(\" \", 100)) \n\n   К тексту приклеится сто пробелов. На деле это не много, и увеличивает отображение примерно на 5 секунд.",
    "answers": [
      {
        "id": 29,
        "text": "   function lua_do()\n       message(\"Привет!\")\n   end",
        "comment": false,
        "lua_do": "function lua_do()\n    message(\"Привет!\")\nend"
      },
      {
        "id": 29,
        "text": "   function lua_do()\n       message(\"Привет!\" .. string.rep(\" \", 100))\n   end",
        "comment": false,
        "lua_do": "function lua_do()\n    message(\"Привет!\" .. string.rep(\" \", 100))\nend"
      },
      {
        "id": 29,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 30,
    "text": "   math.random() даёт нам возмозности получить случайное число из указанных в скобках.\n \n   a = math.random(5)   -- переменная \"а\" примет одно из значений в диапозоне от 1 до указанного в скобках одного числа (в моей записи это 5).\n\n   а = math.random(3, 8)   -- переменная \"а\" примет одно из значений в диапозоне , указанном в скобках (в моей записи от 3 до 8).\n\n   a = math.random()   -- переменная \"а\" примет нецелое значение от 0 до 1\n\n   Запишем в ответ три разных варианта рандома:\n\n   function lua_text()\n       a = math.random(10)\n       b = math.random(11, 16)\n       c = math.random()\n       return \"a = \" .. a ..\"<s>\nb = \" .. b .. \"<s>\nc = \" .. c\n   end",
    "answers": [
      {
        "comment": false,
        "id": 30,
        "instant": true,
        "lua_text": "function lua_text()\n    a = math.random(10)\n    b = math.random(11,16)\n    c = math.random()\n    return \"a = \" .. a ..\"<s>\nb = \" .. b .. \"<s>\nc = \" .. c\nend",
        "text": "  "
      },
      {
        "id": 30,
        "text": "  ",
        "comment": true
      },
      {
        "id": 30,
        "text": "   Еще рандом можно использовать так:\n\n   function lua_text()\n       if math.random(100) < 60 then\n           return \"Вы выиграли в лотерею!\"\n       else\n           return \"Проигрыш...\"\n       end\n   end",
        "comment": true
      },
      {
        "lua_text": "function lua_text()\n    if math.random(100) < 60 then\n        return \"Вы выиграли в лотерею!\"\n    else\n        return \"Проигрыш...\"\n    end\nend",
        "id": 30,
        "text": "  ",
        "instant": true,
        "comment": false
      },
      {
        "id": 30,
        "text": "   Сама конструкция math.random(100) < 60 позволяет просто сгенерировать число от 1 до 100, а затем сравнить с условием. \n   Можно использовать как: if math.random(2) == 1 then ... - то есть сгенерировать значение 1 или 2, и сравнить его соответствие с условием.",
        "comment": true
      },
      {
        "id": 30,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 31,
    "text": "   В возмозностях Луа есть исполнение кода с задержкой во времени:\n\n   timer.performWithDelay(5000, function(event) end)\n\n   Как этим пользоваться? Оператор достаточно вписать в код функции:\n\n   function lua_do()\n       timer.performWithDelay(5000, function(event)\n           --\n       end)\n   end\n\n   В том месте, где я оставил знак \" -- \" нужно вписать код, который будет исполнен с задержкой. Значение 5000 может быть произвольным, но важно понимать, что Луа считает время в миллисекундах, оттого значение 5000 равно 5 секундам (1000 миллисекунд в 1 секунде).\n   \n   Я покажу тебе простой пример. Представь, что ты на военных учениях, и тебе сейчас предстоит сделать бросок гранаты!",
    "answers": [
      {
        "lua_do": "function lua_do()\n    text = \"Граната улетела на \" .. math.random(25,30) .. \" метров. Ты в окопе ожидаешь взрыва.\"\n    timer.performWithDelay(3000, function(event)\n        text = \"Граната взорвалась! Ошмётки земли разлетелимь в разные стороны.\"\n        ff = 1\n        showPage{ id = g.current_id, transition = \"instant\" }\n    end)\nend",
        "text": "Выполнить бросок гранаты",
        "comment": false,
        "id": 31
      },
      {
        "id": 31,
        "text": "   ",
        "comment": true,
        "lua_text": "function lua_text()\n    return text\nend"
      },
      {
        "id": 32,
        "text": "Как добиться такого эффекта? ",
        "var_need": [
          "ff",
          1
        ]
      }
    ]
  },
  {
    "id": 32,
    "text": "   Вот код, который я использовал на ответе с броском гранаты:\n\n",
    "answers": [
      {
        "isBack": true,
        "text": "Назад",
        "backstepCount": 1,
        "id": 32
      },
      {
        "id": 5,
        "text": "В начало"
      },
      {
        "id": 32,
        "text": "   function lua_do()\n       text = \"Граната улетела на \" .. math.random(25, 30) .. \"метров. Ты в окопе ожидаешь взрыва.\"\n       timer.performWithDelay(3000, function(event)\n           text = \"Граната взорвалась! Ошмётки земли разлетелись в разные стороны.\"\n           showPage{ id = g.current_id, transition = \"instant\" }\n       end)\n   end\n\n  Изначально, при нажатии сразу срабатывает вторая строка, которая присваивает переменной \"text\" текстовое значение: \"Граната улетела на...\".\n   Следом включается задержка на 3 секунды, и после неё исполняется вторая часть кода, где переменной \"text\" присваивается другое текстовое значение: \"Граната взорвалась! Ошмётки...\".\n   При этом не забывайте ставить переход на страницу (showPage), чтобы отображались корректные значения. В данном случае, без использования \"showPage\" переменная \"text\" получит новое значение, но изменения на экране не отобразятся.\n    Код для вывода текста на ответ:\n\n   function lua_text()\n       return text\n   end",
        "merge": true
      }
    ]
  },
  {
    "id": 33,
    "text": "   Код объемен, но тем не менее можно настроить нужный эффект.",
    "answers": [
      {
        "id": 33,
        "text": "Короткая вспышка",
        "comment": false,
        "lua_do": "function lua_do()\n     local rect = display.newRect(display.contentCenterX, display.contentCenterY,display.contentCenterX*2, display.contentCenterY*2 )\n    canvas.parent.parent.parent.parent.parent.parent.parent:insert(rect)\n     rect:setFillColor(1,1,1)\n     transition.from(rect, {\n         time = 300,\n         alpha = 0,\n         transition = easing.outExpo,\n         onComplete = function()\n             timer.performWithDelay(200, function(event) --если хочешь подержать белый экран\n                  if rect and rect.removeSelf then\n                      transition.to(rect, {\n                      time = 200,\n                      alpha = 0,\n                      transition = easing.inExpo,\n                      onComplete = function()\n                          if rect and rect.removeSelf then\n                              rect:removeSelf()\n                              rect = nil\n                          end\n                      end\n                    })\n                end\n            end)\n        end\n    })\nend"
      },
      {
        "id": 33,
        "text": "Долгая вспышка",
        "comment": false,
        "lua_do": "function lua_do()\n    local rect = display.newRect(display.contentCenterX, display.contentCenterY,display.contentCenterX*2, display.contentCenterY*2 )\n     canvas.parent.parent.parent.parent.parent.parent.parent:insert(rect)\n    rect:setFillColor(1,1,1)\n    transition.from(rect, {\n        time = 700,\n        alpha = 0,\n        transition = easing.outExpo,\n        onComplete = function()\n            timer.performWithDelay(500, function(event)--если хочешь подержать белый экран\n                 if rect and rect.removeSelf then\n                     transition.to(rect, {\n                         time = 700,\n                         alpha = 0,\n                         transition = easing.inExpo,\n                         onComplete = function()\n                             if rect and rect.removeSelf then\n                                 rect:removeSelf()\n                                 rect = nil\n                             end\n                         end\n                    })\n                end\n            end)\n        end\n    })\nend"
      },
      {
        "id": 33,
        "text": "Быстрое затухание",
        "comment": false,
        "lua_do": "function lua_do()\n     local rect = display.newRect(display.contentCenterX, display.contentCenterY,display.contentCenterX*2, display.contentCenterY*2 )\n     canvas.parent.parent.parent.parent.parent.parent.parent:insert(rect)\n     rect:setFillColor(1,1,1)\n     transition.from(rect, {\n         time = 200,\n         alpha = 0,\n         transition = easing.outExpo,\n         onComplete = function()\n             timer.performWithDelay(500, function(event)--если хочешь подержать белый экран\n                  if rect and rect.removeSelf then\n                      transition.to(rect, {\n                          time = 500,\n                          alpha = 0,\n                          transition = easing.inExpo,\n                          onComplete = function()\n                              if rect and rect.removeSelf then\n                                  rect:removeSelf()\n                                  rect = nil\n                              end\n                          end\n                      })\n                end\n            end)\n        end\n    })\nend"
      },
      {
        "id": 33,
        "text": "Долгое затухание",
        "comment": false,
        "lua_do": "function lua_do()\n    local rect = display.newRect(display.contentCenterX, display.contentCenterY,display.contentCenterX*2, display.contentCenterY*2 )\n    canvas.parent.parent.parent.parent.parent.parent.parent:insert(rect)\n    rect:setFillColor(0,0,0)\n    transition.from(rect, {\n        time = 2000,\n        alpha = 0,\n        transition = easing.outExpo,\n        onComplete = function()\n            timer.performWithDelay(500, function(event)--если хочешь подержать белый экран\n                 if rect and rect.removeSelf then\n                     transition.to(rect, {\n                         time = 500,\n                         alpha = 0,\n                         transition = easing.inExpo,\n                         onComplete = function()\n                             if rect and rect.removeSelf then\n                                 rect:removeSelf()\n                                 rect = nil\n                             end\n                         end\n                     })\n                 end\n            end)\n        end\n    })\nend"
      },
      {
        "id": 33,
        "text": "  ",
        "comment": true
      },
      {
        "id": 34,
        "text": "Смотреть код для данного эффекта "
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 34,
    "text": "   ",
    "answers": [
      {
        "id": 34,
        "text": "   function lua_do()\n       local rect = display.newRect(display.contentCenterX, display.contentCenterY,display.contentCenterX*2, display.contentCenterY*2 )\n       canvas.parent.parent.parent.parent.parent.parent.parent:insert(rect)\n        rect:setFillColor(1,1,1)\n        transition.from(rect, {\n            time = 200,\n            alpha = 0,\n            transition = easing.outExpo,\n            onComplete = function()\n                timer.performWithDelay(300, function(event)\n                    if rect and rect.removeSelf then\n                        transition.to(rect, {\n                            time = 400,\n                            alpha = 0,\n                            transition = easing.inExpo,\n                            onComplete = function()\n                                if rect and rect.removeSelf then\n                                    rect:removeSelf()\n                                    rect = nil\n                                end\n                            end    \n                        })\n                    end\n                end)\n            end\n        })\n    end\n\n   А теперь немного пояснений как добиться желаемого тобой эффекта. Если посмотреть представленный код, то будет видно три больших числа: 200, 300, 400. В зависимости от того, какие цифры стоят на этих местах, будет продолжительность всего эффекта. \n   200 - чем больше это число, тем дольше будет экран покрываться беленой.\n   300 - число в таймере задержки (delay), по истечению которого начинается сниматься белена.\n   400 - чем больше это число, тем дольше будет исчезать белена.\n   Помни, что в 1 секунде 1000 миллисекунд, а Луа работает именно с миллисекундами.\n   Если хочешь, чтобы белело быстро, а исчезала белена долго, то выставлять нужно 200, 200, 2000.\n   Если хочешь, чтобы белело долго, а исчезала белена быстро, то высталять нужно 2000, 2000, 200.\n   \n   Также можно изменить цвет эффекта: для это нужна строка rect:setFillColor(1,1,1).\n   Согласно палитре RGB выставьте значения от 0 до 1 в эти поля. Например (0.43, 0.5, 0.9), (1, 0, 0.33), (0.5, 0.5, 0.5).",
        "comment": false,
        "merge": true
      },
      {
        "isBack": true,
        "text": "Назад",
        "backstepCount": 1,
        "id": 34
      }
    ]
  },
  {
    "id": 35,
    "text": "   Мы ввели вкладки  и правое меню. О их особенностях можно прочитать ниже. Можно ознакомиться с примером реализации в аккаунте 123/123\n\nВ рамках данной задачи нужно проверить:\n​Стабильность меню. Должно выдерживать дергания и тыкания не хуже, чем левое. Ничто не должно забирать тапы, одновременно может быть активно только одно меню.\n​Меню можно выдвинуть только в квесте, только когда соответствующая переменная содержит адекватное значение\n​Все пути выхода из квеста блокируют работу меню\n​Работа ?, ?or, #, #<plus> со страницами во вкладках\n​При переходах на первую страницу, в случаях если появляются кнопки \"продолжить/сначала\", вкладки должны сохраняться. Убедиться, что при продолжении все в порядке.\n​Сбросы прогресса стирают информацию о вкладках\n\nВсе возникшие баги, проблемы, вопросы заводим подзадачами к этой задаче.\n\nИтак, основная цель вкладок — сделать так, чтобы игрок мог находиться на нескольких страницах квеста одновременно. У каждой такой вкладки своя история посещений, своя музыка, свои автораны, (но переменные одинаковые). Для подобного распараллеливания используется переменная \"global tab\", принимающая значения от нуля(стандартный режим, который мы имеем сейчас) до бесконечности. Значения устанавливаются через var set или посредством lua.\nДля оперирования функционалом вкладок теперь есть старенькие, но модифицированные операторы: ?, #, #<plus>, !!. Первые используются чтобы провернуть что-нибудь с историей посещений вкладки. Для этого вместо номера страницы, как раньше, нужна следующая форма записи\n[x, y] где х — это номер вкладки, а у — номер страницы.\n#[ [1, 3] ] — удалить из истории посещений первой вкладки (не забываем, что наша начальная вкладка — нулевая. Чтобы удалить что-то из обычной истории посещений, используем старую форму записи)\n#<plus>[ [2,5], 6 ] — добавить в обычную историю посещений страницу 6, а в историю посещений 2-ой вкладки страницу 5.\n?[ [1,4], 2 ] — проверка, содержится ли в текущей истории страница 4, посещенная во вкладке 1 и страница 2, посещенная во вкладке 0(посещенная как обычно). ?or работает так же, ?? не работает с вкладками, а проверяет, посещена ли страница в принципе хоть где-то.\n!! — шаг назад по истории текущей вкладки. Обратите внимание, что если история вкладки вдруг закончится, игрок вылетит на первую страницу, что приведет к сбросу истории и вкладки.\nКак использовать вкладки:\nДелаем ответ, на котором с помощью var set устанавливаем в переменную \"global tab\" нужный нам номер. Теперь этот ответ приведет игрока на указанную страницу, но это будет уже другая вкладка. Для возврата на то место в другой вкладке, с которого игрок ушел, нужна аналогичная кнопка, устанавливающая \"global tab\" на нужное значение и с оператором !!. \n\nКонечно, было бы удобно как-то собрать вместе кнопки, способные перемещать игрока по вкладкам, чтобы не пихать их на каждую страницу. Эту задачу способно выполнить правое меню — такое же, как привычное всем левое, но его наполнение может контроллировать автор.\nЗаполнение меню происходит, исходя из имеющихся ответов на странице, которая связана с правым меню. Для того, чтобы определить, что на данный момент будет в меню, используется значение переменной \"global side_menu\". С помощью var set присвойте этой переменной номер необходимой вам страницы. Чтобы полностью убрать меню, присвойте 0 или номер любой несуществующей страницы. Страницу, по которой рисуется меню, можно изменять в процессе прохождения квеста.\nОбратите внимание, что пока что меню не обращает внимания на изменения на странице, игнорирует условные операторы. Это значит, что после того, как меню определенной страницы отрисуется, то для этой страницы его уже не изменить. В будущем это, конечно, изменится, но некоторое время придется использовать то, что есть.\nК сожалению, пока реализован не весь функционал. Чего нет, но что в планах, вы можете посмотреть в подтасках к задаче Вкладки для капитана\nС примером реализации меню и системы вкладок можно ознакомиться, открыв последний квест на аккаунте с логином/паролем 123/123\n\nПомните, что и вкладки, и меню вполне могут существовать раздельно. Все зависит только от того, какую систему вы придумаете.\n\nАктуальная версия для тестов(бета) — 305\n\n\n\n",
    "answers": []
  },
  {
    "id": 36,
    "text": "   В рпг-играх можно реализовать бой \"один против нескольких\", или \"группа против группы\".\nЭто не так легко, но и ничего сложного тут особо нет. Давайте пошагово разбираться.\n   Чтобы выбрать врага из нескольки, нужно чтобы эти враги вообще существовали. Давайте запишем их в таблицу:\n\n   ",
    "answers": [
      {
        "id": 36,
        "text": "   enemies = { \"Орк\", \"Волк\", \"Гоблин\", \"Тролль\" }\n\n   Теперь у нас есть враги. У врага должна быть своя характеристика: здоровье, урон, броня, уклонение... но нас интересует только здоровье. \n   Нам нужно будет условие, чтобы игра понимала, что враг жив и может быть выбран в качестве цели: этим условием послужит показатель здоровья выше 0. Ты же согласен, что выбирать в качестве цели атаки уже поверженного врага довольно глупо? \n   Запишем таблицу с показателем здоровья врагов.\n\n   enemiesHp = { 100, 80, 60, 120 }\n\n   Если вам удобно отображать здоровья врага как \"текущее/максимальное\", то есть \"55/100\", то нужно вывести вторую таблицу. Чтобы скопировать её нужно ввести следующий оператор:\n\n   enemiesMaxHp = table.copy2(enemiesHp)\n\n   Теперь есть две таблицы, отчего мы можем вывести показатели врага на вид.\n\n",
        "merge": true
      },
      {
        "id": 36,
        "text": "   function lua_text()\n       text = \"\"\n       for k, v in pairs (enemiesHp) do\n           if enemiesHp[k] > 0 then\n               text = text .. enemies[k] .. \"   \" .. enemiesHp[k] .. \"/\" .. enemiesMaxHp[k] .. \"<s>\n\"\n           end\n       end\n       return text\n   end\n\n   Вот так будет выглядеть этот text:",
        "merge": true
      },
      {
        "id": 36,
        "text": "Орк   100/100\nВолк   80/80\nГоблин   60/60\nТролль   120/120",
        "comment": true
      },
      {
        "id": 36,
        "text": "   В этом коде примечательно то, что в случае гибели врага - он исчезнет из общего списка, ведь условием для вывода имени врага является его показатель текущего здоровья, а именно больше 0.\n   Теперь остаётся написать только сам рандом-выбор:\n\n   function lua_do()\n       lives = { }\n       for k in pairs (enemiesHp) do\n           if enemiesHp[k] > 0 then\n               lives[#lives <plus> 1] = k\n           end\n       end\n       target = lives[math.random(#lives)]\n       targetName = enemies[target]\n   end\n\n   В этом коде исполнение происходит по примеру предшествующего, где вновь идет сравнение с показателем текущего здоровья. Если оно больше 0, то он, враг, заносится в список (таблицу) lives, из которого он потом может быть выббран в качестве цели.",
        "comment": true
      },
      {
        "id": 37,
        "text": "Практика",
        "lua_do": "function lua_do()\n    atk = 0\nend"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 37,
    "text": "   Враги:\n",
    "answers": [
      {
        "super_calculate": false,
        "lua_do": "function lua_do()\n    enemies = { \"Орк\", \"Волк\", \"Гоблин\", \"Тролль\" }\n    enemiesHp = { 100, 80, 60, 120 }\n    enemiesMaxHp = table.copy2(enemiesHp)\nend",
        "text": "   ",
        "id": 37,
        "calculate": true
      },
      {
        "id": 37,
        "text": "   ",
        "calculate": true,
        "super_calculate": false
      },
      {
        "id": 37,
        "text": "  ",
        "lua_text": "function lua_text()\n    text = \"\"\n    for k, v in pairs (enemiesHp) do\n        if enemiesHp[k] > 0 then\n            text = text .. enemies[k] .. \"   \" .. enemiesHp[k] .. \"/\" .. enemiesMaxHp[k] .. \"<s>\n\"\n        end\n    end\n    return text\nend",
        "merge": true
      },
      {
        "id": 37,
        "text": "Атаковать",
        "comment": false,
        "lua_do": "function lua_do()\n    atk = 1\n    lives = { }\n    for k in pairs (enemiesHp) do\n        if enemiesHp[k] > 0 then\n            lives[#lives<plus>1] = k\n        end\n    end\n    target = lives[math.random(#lives)]\n    targetName = enemies[target]\nend"
      },
      {
        "var_show": [
          "targetName"
        ],
        "comment": true,
        "id": 37,
        "text": "Атакован:",
        "lua_if": "function lua_if()\n    return atk >= 1\nend"
      },
      {
        "var_show": [
          "target"
        ],
        "comment": true,
        "id": 37,
        "text": "Номер врага:",
        "lua_if": "function lua_if()\n    return atk >= 1\nend"
      },
      {
        "id": 39,
        "text": "Посмотреть полный код",
        "lua_if": "function lua_if()\n    return atk >= 1\nend"
      },
      {
        "id": 5,
        "text": "В начало",
        "lua_if": "function lua_if()\n    return atk >= 1\nend"
      }
    ]
  },
  {
    "id": 38,
    "text": "   Для создания копии таблицы нужно использовать функцию table.copy2. Вот пример:\n\n   enemyName = table.copy2(enemies)\n\n   Таблица enemyName — новая таблица, которая будет заполнена значениями из таблицы enemies. Он создаёт полноценную копию таблицы, а не ссылку на неё, тем самым позволяет работать с каждой из них по отдельности.",
    "answers": [
      {
        "id": 5,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 39,
    "text": "   Заводим таблицу врагов:",
    "answers": [
      {
        "id": 39,
        "text": "   function lua_do()\n       enemies = { \"Орк\", \"Волк\", \"Гоблин\", \"Тролль\" }\n       enemiesHp = { 100, 80, 60, 120 }\n       enemiesMaxHp = table.copy2(enemiesHp)\n   end",
        "comment": true
      },
      {
        "id": 39,
        "text": "   Написать функцию вывода состояния здоровья врага:",
        "comment": true
      },
      {
        "id": 39,
        "text": "   function lua_text()\n       text = \"\"\n       for k, v in pairs (enemiesHp) do\n           if enemiesHp[k] > 0 then\n               text = text .. enemies[k] .. \"   \" .. enemiesHp[k] .. \"/\" .. enemiesMaxHp[k] .. \"<s>\n\"\n           end\n       end\n      return text\n  end",
        "comment": true
      },
      {
        "id": 39,
        "text": "   Написать систему выбора цели:",
        "comment": true
      },
      {
        "id": 39,
        "text": "   function lua_do()\n       lives = { }\n       for k in pairs (enemiesHp) do\n           if enemiesHp[k] > 0 then\n               lives[#lives <plus> 1] = k\n           end\n       end\n       target = lives[math.random(#lives)]\n       targetName = enemies[target]\n   end",
        "comment": true
      },
      {
        "id": 39,
        "text": "   В target будет генерироваться номер врага, а затем дублироваться в targetName для вывода его имени.\n   Например, для вычета здоровья врага можно использовать:\n\n   enemiesHp[target] = enemiesHp[target] - damage\n\n   Для вывода имени врага можно использовать:\n\n   \"Ты провёл атаку, и \" .. targetName .. \" получил \" .. damage .. \" урона.\"",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 40,
    "text": "   ",
    "answers": [
      {
        "id": 40,
        "text": "Вообще понятие объекта относится к сфере так называемого объектно-ориентированного программирования, которое реализуется, например, в таких языках как C<plus><plus>, C#, Visual Basic и многих других. Lua — это не объектно-ориентированный язык, но, как мы уже говорили в самом начале курса, он настолько гибок, что вполне допускает реализацию этой парадигмы.\n\n   Этой особенностью Lua и воспользовались разработчики Corona для работы с экранными (и не только) объектами в своём движке.\n\n   Что такое объект в Lua. Говоря простым языком, это таблица, в которой содержатся не только данные, но и функции. Ячейки с данными называются полями, а ячейки с функциями — методами.\n\n   Объектно-ориентированный подход к программированию позволяет моделировать механизмы, которые мы видим в реальности. Вот, к примеру, есть человек. У него есть имя, возраст, карие глаза, чёрные волосы, белая кожа. Это поля. Этот человек может есть, читать, заниматься спортом, писать картины, чихать. Это его методы.\n\n  Понятие поля отвечает на вопрос: какие у объекта свойства? Понятие метода отвечает на вопрос: что объект умеет делать?\n\n   Поле — это полный аналог переменной, только содержится она внутри таблицы.\n\n   myObject.color = \"red\"\n\n   Этот оператор присваивает полю \"color\" объекта myObject текстовое значение \"red\". Мы с вами это всё проходили. Здесь нет ничего принципиально нового.\n\n   А вот с методами не так.\n\n   Дело в том, что в Lua функции — это такие же точно значения как, например, строка или число. И они точно так же могут присваиваться полям таблицы.\n\n   В следующем примере создаётся пустой объект Porshen, а потом для него создаётся метод sleep. Код нужно вставить в ответ с калькулейтом.\n\n   function lua_do()\n       Porshen = {}\n       Porshen.sleep = function(sleepTime, awakeTime)\n           if tonumber(os.date(\"%H\")) > sleepTime and tonumber(os.date(\"%H\")) > awakeTime then\n               return \"Не будите! Я только спать лёг!\"\n           elseif tonumber(os.date(\"%H\")) < sleepTime and tonumber(os.date(\"%H\")) < awakeTime then\n               return \"Отстаньте! Ещё вставать рано!\"\n           else\n               return \"Я бодр, и свеж, и полон надежд!\"\n           end\n       end\n   end\n\n   Этот метод принимает два аргумента — sleepTime (время ложиться спать) и awakeTime (время просыпаться). Оба аргумента для простоты примера передаются в часах.\n\n   Метод сверяет переданные параметры с текущим временем и в качестве результата своей работы возвращает текстовое сообщение, соответствующее ситуации.\n\n   Теперь мы можем вызывать этот метод как обычную функцию:\n\n   message = Porshen.sleep(22, 6)\n\n   Теперь в переменной message будет храниться одно из трёх текстовых сообщений, предусмотренных методом, и зависеть оно будет от того, в какое время вызван метод и какие аргументы ему переданы.\n\n   Гораздо более эффектным подходом будет вызывать метод не в операторе присваивания, а непосредственно в функции lua_text. Создайте ответ и напишите в нём следующий код:\n\n   function lua_text()\n       return Porshen.sleep(20, 6)\n   end\n\n   Перейдите в режим читателя и полюбуйтесь результатом. Если текущее время будет попадать в промежуток между значениями второго и первого числа, вы увидите третье сообщение. В противном случае Поршень пошлёт вас с просьбой не мешать ему спать.\n\n   Можете поэкспериментировать со значениями аргументов, но помните, что первый аргумент функции должен всегда быть больше второго. В противном случае функция не будет корректно работать.\n\n   Вы, наверное, спросите: «Ну чем же тогда метод отличается от обычной функции?» По большому счёту — ничем. Во всяком случае в этом примере.\n\n   Однако имеются некоторые особенности, которые отличают методы от обычных функций. Давайте об этом поговорим.\n\n   Для начала немного переделаем запись предыдущего примера и объявим метод более подобающим и традиционным для Lua способом.\n\n   function lua_do()\n       Porshen = {}\n       function Porshen.sleep(sleepTime, awakeTime)\n           if tonumber(os.date(\"%H\")) > sleepTime and tonumber(os.date(\"%H\")) > awakeTime then\n               return \"Не будите! Я только спать лёг!\"\n           elseif tonumber(os.date(\"%H\")) < sleepTime and tonumber(os.date(\"%H\")) < awakeTime then\n               return \"Отстаньте! Ещё вставать рано!\"\n           else\n               return \"Я бодр, и свеж, и полон надежд!\"\n           end\n       end\n   end",
        "merge": true
      },
      {
        "id": 40,
        "text": "\n\n   Код не сильно отличается. Изменилось только само объявление функции: вместо Porshen.sleep = function(sleepTime, awakeTime) мы записали function Porshen.sleep(sleepTime, awakeTime).\n\n   Эти записи абсолютно эквивалентны, просто вторая нам предоставит кое-какие дополнительные возможности, а именно — удобный механизм для обращения к полям объекта.\n\n   В предыдущем примере мы эти поля не использовали. А вся мощь объектно-ориентированного программирования как раз и заключается в том, что объекты реализуют методы, использующие данные из своих полей.\n\n   Например, я захотел подтянуться на турнике. Я реализую метод «подтягивание», но для расчёта результата метод должен обратиться к полям, в которых хранятся показатели моей текущей мускульной силы и мой вес. Смекаете?\n\n   Давайте передадим Поршню показатели его веса, мускульной силы и напишем для него метод pullUp.\n\n   function lua_do()\n       Porshen = { weight = 80, strength = 350 }\n       function Porshen.pullUp()\n           return math.round(Porshen.strength / Porshen.weight)\n       end\n   end\n\n   Теперь мы можем обращаться к этой функции и получить от неё результат, зависящий исключительно от характеристик Поршня.\n\n   function lua_text()\n       return \"Поршень подтянулся \"..Porshen.pullUp()..\" раз.\"\n   end\n\n   Отлично. Но на самом деле это не все плюшки, которые даёт нам Lua. Не верно и неудобно каждый раз внутри метода объекта обращаться к самому объекту, указывая его имя. Эта запись полностью исключает такой важнейший для объектно-ориентированного программирования инструмент как наследование. Этот объект не сможет послужить прототипом для другого, который имеет все поля и методы родителя, но добавляет ещё и свои.\n\n   Например родительским объектом-прототипом собаки является объект «млекопитающее». У млекопитающего имеются методы «есть», «размножаться», «кормить молоком». Собака наследует все эти методы и добавляет к ним свои собственные — «лаять», «вычёсывать блох», «приносить палку».\n\n   Чтобы реализовать механизм наследования, мы должны внутри методов объекта обращаться к нему не по имени, а с помощью специально выделенного параметра self. Для этого методу в качестве первого аргумента передаётся сам объект.\n\n   function lua_do()\n       Porshen = { weight = 80, strength = 350 }\n       function Porshen:pullUp()\n           return math.round(self.strength / self.weight)\n       end\n   end\n\n   function lua_text()\n       return \"Поршень подтянулся \"..Porshen:pullUp()..\" раз.\"\n   end\n\n   Обратили внимание на изменения? Теперь при обращении к методу pullUp путём индексации объекта Porshеn мы используем не точку, а двоеточие, а внутри для обращения к объекту используем слово self.\n\n   По сути двоеточие просто упрощает запись следующего вида:\n\n   function lua_do()\n       Porshen = { weight = 80, strength = 350 }\n       function Porshen.pullUp(self)\n           return math.round(self.strength / self.weight)\n       end\n   end\n\n   function lua_text()\n       return \"Поршень подтянулся \"..Porshen.pullUp(Porshen)..\" раз.\"\n   end\n\n   Двоеточие позволяет автоматически в качестве первого аргумента передать внутрь метода объект, которому он принадлежит, и обращаться к нему через ключевое слово self.\n\n   И при вызове метода тоже нет необходимости второй раз добавлять имя объекта в скобках.\n\n    Эти обе записи абсолютно равноправны, и вы можете использовать любую из них, если захотите.\n\n   Теперь вы имеете представление, что такое объекты, методы и их поля.\n\n   На самом деле тема объектов гораздо обширнее, но мы не будем ей пока заниматься. Того, что мы сегодня изучили, вполне достаточно, чтобы начать работать с полотном.",
        "merge": true
      },
      {
        "id": 12,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 41,
    "text": "   Конкатенация — объединение, \"склеивание\". В коде луа записывается как две точки ( .. ). Сложно объяснить её словами развёрнуто, поэтому рассмотрим несколько примеров.\n\n   function lua_do()\n       a = \"Привет\"\n       b = \"мир\"\n       с = a .. b\n   end\n\n   В таком коде переменная \"с\" получит значение \"Приветмир\". Вышло слитно, без пробела и запятой. Исправим?\n\n   function lua_do()\n       a = \"Привет,\"\n       b = \" мир!\"\n       с = a .. b\n   end\n\n   В переменной \"а\" добавили запятую после слова \"привет\", а в переменной \"b\" добавили пробел перед словом \"мир\" и восклицательный знак после него. В результате переменная \"с\" получает значение \"Привет, мир!\"\n\n   А теперь представьте, что мне нужно выводить рандом-значение переменной.\n\n   function lua_text()\n       return \"Получено: \" .. math.random(5, 15) .. \" опыта.\"\n   end\n   \n   В ответе будет записано следующее: \"Получено 7 опыта.\" Вместо \"7\" может быть другое рандом-значение, но сути это не меняет.",
    "answers": [
      {
        "id": 42,
        "text": "Создание лога разговора",
        "lua_do": "function lua_do()\n    text = \"- И как долго ты тут собираешься торчать?\"\n    ask = 0\nend"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 42,
    "text": "Давай поиграем? ",
    "answers": [
      {
        "id": 42,
        "text": "    ",
        "comment": true,
        "lua_text": "function lua_text()\n    return text\nend"
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    ask = 1\n    text = text .. \"<s>\n- Не твоё дело! <s>\n<s>\n- А ты не из робкого десятка! Уже беседовал с Майком по поводу новой работы?\"\nend",
        "text": "- Не твоё дело!",
        "lua_if": "function lua_if()\n    return ask == 0\nend",
        "id": 42
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    ask = 2\n    text = text .. \"<s>\n- Я ищу выход. <s>\n<s>\n- М-да! Майк такого точно не захочет брать в отряд на новое задание!\"\nend",
        "text": "- Я ищу выход.",
        "lua_if": "function lua_if()\n    return ask == 0\nend",
        "id": 42
      },
      {
        "lua_if": "function lua_if()\n    return ask == 1\nend",
        "id": 42,
        "text": "- Да, был. А тебе-то что? ",
        "lua_do": "function lua_do()\n    text = text .. \"<s>\n-  Да, а тебе-то что?<s>\n<s>\n- Да не злись ты: работа у меня такая - вопросы всем задавать.\"\n    ask = 3\nend",
        "comment": false
      },
      {
        "lua_if": "function lua_if()\n    return ask == 1\nend",
        "lua_do": "function lua_do()\n    text = text .. \"<s>\n- Нет, меня это не интересует.<s>\n<s>\n- Жаль. В его команду нужны такие уверенные ребята.\"\n    ask = 3\nend",
        "text": "- Нет, меня это не интересует.",
        "comment": false,
        "id": 42
      },
      {
        "lua_if": "function lua_if()\n    return ask == 2\nend",
        "lua_do": "function lua_do()\n    text = text .. \"<s>\n- Новое задание?<s>\n<s>\n- Да я это так, к слову. Выход там.\"\n    ask = 3\nend",
        "text": "- Новое задание? ",
        "comment": false,
        "id": 42
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    text = text .. \"<s>\n- Сдалось оно мне!<s>\n<s>\n- Как знаешь. Выход там.\"\n    ask = 3\nend",
        "text": "- Сдалось оно мне!",
        "id": 42,
        "lua_if": "function lua_if()\n    return ask == 2\nend"
      },
      {
        "id": 43,
        "text": "Уйти",
        "lua_if": "function lua_if()\n    return ask == 3\nend"
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    text = \"- И как долго ты тут собираешься торчать?\"\n    ask = 0\nend",
        "text": "[Повторить]",
        "lua_if": "function lua_if()\nreturn ask == 3\nend",
        "id": 42
      }
    ]
  },
  {
    "id": 43,
    "text": "   Вот небольшой пример с диалогом. Теперь я напишу сюда все ответы с кодом, который я использовал...",
    "answers": [
      {
        "id": 43,
        "text": "   function lua_do()\n       text = \"- И как долго ты тут собираешься торчать?\"\n       ask = 0\n   end\n\n   Это на кнопке перед началом \"разговора\", и на кнопке \"повторить\".",
        "comment": true
      },
      {
        "id": 43,
        "text": "   function lua_text()\n       return text\n   end\n\n   Это на основном ответе-отображении. Именно переменная text содержит в себе весь разговор, а на данный момент она сохранила только значение \"- И как долго ты тут собираешься торчать?\"",
        "comment": true
      },
      {
        "id": 43,
        "text": "   function lua_do()\n       ask = 1\n       text = text .. \"<s>\n- Не твоё дело!<s>\n<s>\n- А ты не из робкого десятка! Уже беседовал с Майком по поводу новой работы?\"\n   end\n\n   function lua_if()\n       return ask == 0\n   end\n\n   Это один из ответов на первый вопрос. Что мы видим по коду? \"text = text\" означает, что значение переменной text не меняется, но к нему присоединяется \"..\" значение \"<s>\n- Не твоё дело! ...\".\n   <s>\n - системное значение, которое создаёт перенос строки (enter). <s>\n<s>\n - двойной перенос строки (двойной enter).",
        "comment": true
      },
      {
        "id": 43,
        "text": "   function lua_do()\n       ask = 2\n       text = text .. \"<s>\n- Я ищу выход.<s>\n<s>\n- М-да! Майк такого точно не захочет брать в отряд на новое задание!\"\n   end\n\n   function lua_if()\n       return ask == 0\n   end\n\n   Второй ответ на первый вопрос. Он просто содержит другой текст, а так - всё тоже самое.",
        "comment": true
      },
      {
        "id": 43,
        "text": "   function lua_do()\n       text = text .. \"<s>\n-  Да, а тебе-то что?<s>\n<s>\n- Да не злись ты: работа у меня такая - вопросы всем задавать.\"\n       ask = 3\n   end\n\n   function lua_if()\n       return ask == 1\n   end",
        "comment": true
      },
      {
        "id": 43,
        "text": "   function lua_do()\n       text = text .. \"<s>\n- Нет, меня это не интересует.<s>\n<s>\n- Жаль. В его команду нужны такие уверенные ребята.\"\n       ask = 3\n   end\n\n   function lua_if()\n       return ask == 1\n   end\n\n   Два варианта ответов на второй вопрос.",
        "comment": true
      },
      {
        "id": 43,
        "text": "   function lua_do()\n       text = text .. \"<s>\n- Новое задание?<s>\n<s>\n- Да я это так, к слову. Выход там.\"\n       ask = 3\n   end\n\n   function lua_if()\n       return ask == 2\n   end",
        "comment": true
      },
      {
        "id": 43,
        "text": "   function lua_do()\n       text = text .. \"<s>\n- Сдалось оно мне!<s>\n<s>\n- Как знаешь. Выход там.\"\n       ask = 3\n   end\n\n   function lua_if()\n       return ask == 2\n   end\n\n   Еще два варианта ответа по другой цепочке разговора.",
        "comment": true
      },
      {
        "id": 43,
        "text": "   \"Уйти\"\n\n   function lua_if()\n       return ask == 3\n   end",
        "comment": true
      },
      {
        "id": 42,
        "text": "Еще раз пройти диалог",
        "lua_do": "function lua_do()\n    text = \"- И как долго ты тут собираешься торчать?\"\n    ask = 0\nend"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 44,
    "text": "    Если ещё не рассматривали написание диалоговых окон, то стоит сначала изучить его. А тем, кто уже — продолжим.\n   Вот список опций, которые можно использовать для составления и индивудуализации диалогового окна:\n\n   ",
    "answers": [
      {
        "id": 44,
        "text": "dialog{\n    header = \"текст\", \n    text = \"текст\",\n    fontSizeForHeader = 1.5,\n    fontSizeForBody = 0.7,\n    visibility = 0.7,\n    background = { 0.3, 0.4, 0.3 },\n    textColorForHeader = { 1, 1, 1 },\n    textColorForBody = { 1, 0.7, 0.5 },\n    answers = {\n        {\n            text = \"текст\",\n            fontSize = 1.6,\n            textColor = { 0.4, 0.9, 0.3 },\n            background = { 1, 0.3, 0.1 },\n            pressEffect = { 0.2, 0.3, 1 },\n            disablePressEffect = true,\n            pressListener = function() \n                hideDialog() \n            end\n        }\n    }\n}\n\n   ",
        "comment": false,
        "merge": true
      },
      {
        "id": 44,
        "text": "Помним, что в кавычках записываем текст, который будет выведен в соответствующих полях. \n\n   ВАЖНО! После каждой опции нужно ставить запятую \",\". В противном случае код будет нерабочим, с ошибкой. Еще раз посмотрите на записанный код выше - после каждой опции стоит \",\". \n\n   Рассмотрим же, что делает каждая опция отдельно.\n\n   dialog{\n       header = \"текст\",\n       text = \"текст\",\n       -- Стандартное начало диалогового окна.\n\n       fontSizeForHeader = 1.5,\n       -- Коэффициент увеличение/уменьшение размера шрифта текста Заголовка. Не рекомендуется выставлять слишком большие значения.\n\n       fontSizeForBody = 0.7,\n       -- Коэффициент увеличения/уменьшения размера шрифта основного текста.\n\n       visibility = 0.7,\n       -- Прозрачность фона вокруг диалогового окна. Имеет значение от 0 до 1, где 1 - полностью чёрный фон, а 0 - совсем без затемнения.\n\n       background = { 0.3, 0.4, 0.3 }\n       -- Определяет цвет фона диалогового окна. Выставляется в диапозоне от 0 до 1 в нецелом значении. Подробнее о получении нужного цвета читайте в учебнике \"операторы для сложных квестов\" - \"изменение цвета текста...\". Также можно использовать свой фон-картинку (background = \" https://imgbb.ru/dd59b24d3e7c.png\")\n\n",
        "merge": true
      },
      {
        "id": 44,
        "text": "       textColorForHeader = { 1, 1, 1 },\n       -- Смена цвета текста Заголовка.\n\n       textColorForBody = { 1, 0.7, 0.5 },\n       -- Смена цвета основного текста.\n\n       answers = {\n           {\n               text = \"текст\",\n               -- Функция для создания ответов к диплоговому окну.\n\n               fontSize = 1.6,\n               -- Коэффициент увеличение/уменьшения размера шрифта текста в ответе.\n\n               textColor = { 0.4, 0.9, 0.3 },\n               -- Смена цвета текста ответа.\n\n               background = { 1, 0.3, 0.1 },\n               -- Установка цвета фона на ответе. Вместо цвета можно поставить свой фон-картинку (background = \"https://imgbb.ru/255710c69.png\")\n\n",
        "merge": true
      },
      {
        "id": 44,
        "text": "               pressEffect = { 0.2, 0.3, 1 },\n               -- Эффект от нажатия, то есть реакция кнопки на клик. Установить цвет.\n\n               disablePressEffect = true,\n               -- Используется отдельно от pressEffect, и отключает эффект при нажатие кнопки.\n\n               pressListener = function() \n               -- Функция исполняет вписанный после неё пользовательский код.\n\n                   hideDialog() \n                   -- Стандартная функция для закрытия диалогового окна.\n\n               end\n           }\n       }\n   }",
        "merge": true
      },
      {
        "id": 45,
        "text": "Примеры"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 45,
    "text": "Примеры.",
    "answers": [
      {
        "id": 45,
        "text": "   function lua_do()\n       dialog{\n           header = \"Лесной волк\", \n           text = \"Данный вид предпочитает охотиться стаей, и загоняет свою жертву в ловушку. Одиночки лесных волков встречают крайне редко, в отличии от их степных и горных собратьев.\",\n           background = { 0.2, 0.8, 0.3},\n           answers = {\n               {\n                   text = \"Понял\",\n                   background = { 0.2, 0.8, 0.8 },\n                   pressListener = function() \n                      hideDialog()\n                  end\n              }\n          }\n      }\n   end",
        "comment": false,
        "lua_do": "function lua_do()\n    dialog{\n        header = \"Лесной волк\", \n        text = \"Данный вид предпочитает охотиться стаей, и загоняет свою жертву в ловушку. Одиночки лесных волков встречают крайне редко, в отличии от их степных и горных собратьев.\",\n        background = { 0.2, 0.8, 0.3},\n        answers = {\n            {\n                text = \"Понял\",\n                background = { 0.2, 0.8, 0.8 },\n                pressListener = function() \n                   hideDialog()\n               end\n           }\n       }\n   }\nend"
      },
      {
        "id": 45,
        "text": "   function lua_do()\n       dialog{\n           header = \"Лесной волк\", \n           text = \"Данный вид предпочитает охотиться стаей, и загоняет свою жертву в ловушку. Одиночки лесных волков встречают крайне редко, в отличии от их степных и горных собратьев.\",\n           background = { 0, 0, 0 },\n           textColorForHeader = { 0.5, 0.7, 09 },\n           textColorForBody = { 1, 0.7, 0.5 },\n           answers = {\n               {\n                   text = \"Понял\",\n                   fontSize = 1.2,\n                   textColor = { 0.4, 0.9, 0.3 },\n                   background = { 1, 0.3, 0.1 },\n                   pressListener = function() \n                       hideDialog()\n                  end\n              }\n          }\n      }\n   end",
        "comment": false,
        "lua_do": "function lua_do()\n    dialog{\n        header = \"Лесной волк\", \n        text = \"Данный вид предпочитает охотиться стаей, и загоняет свою жертву в ловушку. Одиночки лесных волков встречают крайне редко, в отличии от их степных и горных собратьев.\",\n        background = { 0, 0, 0 },\n        textColorForHeader = { 0.5, 0.7, 09 },\n        textColorForBody = { 1, 0.7, 0.5 },\n        answers = {\n            {\n                text = \"Понял\",\n                fontSize = 1.2,\n                textColor = { 0.4, 0.9, 0.3 },\n                background = { 1, 0.3, 0.1 },\n                pressListener = function() \n                    hideDialog()\n               end\n           }\n       }\n   }\nend"
      },
      {
        "id": 45,
        "text": "   function lua_do()\n       dialog{\n           header = \"Лесной волк\", \n           text = \"Данный вид предпочитает охотиться стаей, и загоняет свою жертву в ловушку. Одиночки лесных волков встречают крайне редко, в отличии от их степных и горных собратьев.\",\n           fontSizeForHeader = 1.2,\n           fontSizeForBody = 1.2,\n           visibility = 1,\n           background = { 0, 0, 0 },\n           textColorForHeader = { 1, 1, 1 },\n           textColorForBody = { 1, 1, 1 },\n           answers = {\n               {\n                   text = \"Понял\",\n                   fontSize = 1.2,\n                   textColor = { 0, 0, 0 },\n                   background = { 1, 1, 1 },\n                   pressListener = function() \n                       hideDialog()\n                   end\n               }\n           }\n       }\n   end",
        "comment": false,
        "lua_do": "function lua_do()\n    dialog{\n        header = \"Лесной волк\", \n        text = \"Данный вид предпочитает охотиться стаей, и загоняет свою жертву в ловушку. Одиночки лесных волков встречают крайне редко, в отличии от их степных и горных собратьев.\",\n        fontSizeForHeader = 1.2,\n        fontSizeForBody = 1.2,\n        visibility = 1,\n        background = { 0, 0, 0 },\n        textColorForHeader = { 1, 1, 1 },\n        textColorForBody = { 1, 1, 1 },\n        answers = {\n            {\n                text = \"Понял\",\n                fontSize = 1.2,\n                textColor = { 0, 0, 0 },\n                background = { 1, 1, 1 },\n                pressListener = function() \n                    hideDialog()\n                end\n            }\n        }\n    }\nend"
      },
      {
        "id": 45,
        "text": "   ",
        "comment": true
      },
      {
        "id": 44,
        "text": "Назад"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 46,
    "text": "   Есть такие переменные, которые позволят вам создать боковое игровое меню. При этом содержание меню вы определите сами.\n\n   g.side_menu = 10\n   g.right_icon = \"https://a7.ru/5fee9b66.png\"\n   g.menu_background = \"https://al.ru/e5909c7.jpg\"\n\n   g.side_menu = 10 — переменная, которая позволит включить сайд-меню, а вместо значения 10 нужно вписать номер страницы, которая и будет содержанием этого меню.\n   g.right_icon = \"ссылка\" — это сам значок (и ссылка на него) этого бокового меню. Сейчас его видно в верхнем правом углу (три полоски).\n   g.menu_background = \"ссылка\" — это фон сайд-меню. Можно обойтись и без него — он не обязателен для работоспособности сайд-меню.\n\n   Меню можно отключить, но значок никуда не исчезнет. Для этого нужно задать переменной g.side_menu значение 0:\n\n  g.side_menu = 0\n\n   Для включения сайд-меню вновь — нужно задать значение страницы к этой же переменной. Исходя из текущего примера:\n\n   g.side_menu = 10\n\n   Чтобы заполнить сайд-меню нужно: создать страницу, которая будет тем самым меню; создать нужные ответы, которые будут в этом меню; настроить эти ответы, чтобы визуализировать их в меню.\n   Особенностью является то, что это пассивная страница, и она не выполняет записанный на ней lua_text и var show. Но срабатывает lua_if, lua_do и прочие квестовые операторы условий. Также не отображается написанный текст на странице, и не срабатывает merge. \n   Для примера можно видеть кнопку \"под 1\", которая имеет условие отображения lua_if и исполнение lua_do. Для примера я направляю на текущую страрицу, чтобы не пересылать никуда при помощи showPage id = 10 и no transition. Стоит нажать на неё, как сайд-меню закроется, но вместо \"под 1\" будет ответ \"под 2\", который имеет другие условия отображения. Тоже самое будет и с \"под 3\", который обнулит значение переменной, которая отвечает на условие отображение этих \"под\"-ответов.\n   Давайте же подумаем, для чего можно использовать это сайд меню? \n   Самое логичное, что приходит на ум — навигация. Если это квест с поместьем, где можно передвигаться из комнаты в комнату... Или рпг-игра с открытым миром, состоящая из множества локаций (для этого можно создать несколько страниц под сайд-меню, и переключаться между ними, забивая в переменную g.side_menu нужное значение).\n   Также можно сделать быстрое меню для доступа к основным характеристикам персонажа, например, инвентарю, состоянию персонажа, отношения окружающих персонажей. \n   \n   Важно помнить, что читатель может воспользоваться сайд-меню в любой момент, если меню не отключено, а значит нужно позаботиться о том, чтобы потом вернуть читателя на прежнюю страницу.\n   \n   Можно использовать в ответах message и вызов диалоговых окон.\n   inactive — работает.\n   left/right/middle — не работают.",
    "answers": [
      {
        "comment": false,
        "id": 46,
        "text": "Выключить сайд-меню",
        "lua_do": "function lua_do()\n    g.side_menu = 0\nend",
        "lua_if": "function lua_if()\n    return g.side_menu > 0\nend"
      },
      {
        "comment": false,
        "id": 46,
        "text": "Включить сайд-меню",
        "lua_do": "function lua_do()\n    g.side_menu = 47\n    g.right_icon = \"https://c.rff.ru/c27/1911/a7/5fee0cf29b66.png\"\n    g.menu_background = \"https://c.rff.ru/c26/1911/b8/e5989a1409c7.jpg\"\nend",
        "lua_if": "function lua_if()\nreturn g.side_menu == 0\nend"
      },
      {
        "id": 48,
        "text": "Посмотреть саму страницу, которая становится в сайд-меню"
      },
      {
        "id": 5,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 47,
    "text": "сайд-меню",
    "answers": [
      {
        "id": 5,
        "text": "В главное меню",
        "bg_color": [
          1,
          0.7,
          0.3
        ]
      },
      {
        "id": 47,
        "text": "ответ с inactive",
        "comment": true,
        "bg_color": [
          1,
          0.7,
          0.3
        ]
      },
      {
        "id": 1,
        "text": "На первую страницу",
        "bg_color": [
          0.1,
          0.1,
          0.5
        ],
        "text_color": [
          1,
          1,
          1
        ]
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    pod = 1\nend",
        "id": 47,
        "text": "под 1",
        "lua_if": "function lua_if()\n    return not pod\nend",
        "go_to": [
          "global current_id"
        ]
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    pod = 2\nend",
        "id": 47,
        "text": "под 2",
        "lua_if": "function lua_if()\n    return pod == 1\nend",
        "go_to": [
          "global current_id"
        ]
      },
      {
        "comment": false,
        "lua_text": "function lua_text()\n    return \"тут текст pod 3\"\nend",
        "lua_if": "function lua_if()\n    return pod == 2\nend",
        "id": 47,
        "text": "под 3",
        "lua_do": "function lua_do()\n    pod = nil\nend",
        "go_to": [
          "global current_id"
        ]
      },
      {
        "id": 47,
        "text": "   ",
        "comment": true
      },
      {
        "id": 47,
        "text": "= закрыть меню =",
        "go_to": [
          "global current_id"
        ]
      }
    ]
  },
  {
    "id": 48,
    "text": "сайд-меню",
    "answers": [
      {
        "id": 5,
        "text": " В главное меню\n\n bg color [1, 0.7, 0.3]",
        "bg_color": [
          1,
          0.7,
          0.3
        ]
      },
      {
        "id": 47,
        "text": "ответ с inactive",
        "comment": true,
        "bg_color": [
          1,
          0.7,
          0.3
        ]
      },
      {
        "id": 1,
        "text": " На первую страницу\n\n text color [1, 1, 1]\n bg color [0.1, 0.1, 0.5]",
        "bg_color": [
          0.1,
          0.1,
          0.5
        ],
        "text_color": [
          1,
          1,
          1
        ]
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    pod = 1\nend",
        "id": 47,
        "text": " goto [\"global current_id\"]\n\n function lua_do()\n     pod = 1\n end\n \n function lua_if()\n     return not pod\n end",
        "lua_if": "function lua_if()\n    return not pod\nend",
        "go_to": [
          "global current_id"
        ]
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    pod = 2\nend",
        "id": 47,
        "text": " goto [\"global current_id\"]\n\n function lua_do()\n     pod = 2\n end\n\n function lua_if()\n     return pod == 1\n end",
        "lua_if": "function lua_if()\n    return pod == 1\nend",
        "go_to": [
          "global current_id"
        ]
      },
      {
        "lua_text": "function lua_text()\n    return \"тут текст pod 3\"\nend",
        "comment": false,
        "lua_do": "function lua_do()\n    pod = nil\nend",
        "id": 47,
        "text": " goto [\"global current_id\"]\n\n function lua_do()\n     pod = nil\n end\n\n function lua_if()\n     return pod == 2\n end",
        "lua_if": "function lua_if()\n    return pod == 2\nend",
        "go_to": [
          "global current_id"
        ]
      },
      {
        "id": 48,
        "text": "   ",
        "comment": true
      },
      {
        "id": 47,
        "text": " = закрыть меню =\n\n goto [\"global current_id\"]",
        "go_to": [
          "global current_id"
        ]
      },
      {
        "id": 48,
        "text": "   ",
        "comment": true
      },
      {
        "id": 48,
        "text": "   ",
        "comment": true
      },
      {
        "id": 46,
        "text": "[[ вернуться назад ]]",
        "middle_answer": true
      }
    ]
  },
  {
    "id": 49,
    "text": "      ",
    "answers": [
      {
        "id": 50,
        "text": "Подтвердить",
        "lua_do": "function lua_do()\n    text55 = inputText.text\n    display.remove(inputText)\nend"
      },
      {
        "id": 49,
        "text": "   ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      },
      {
        "super_calculate": false,
        "id": 49,
        "text": "nemo",
        "calculate": false,
        "url": "http://188.120.236.127/hc/island/treasure.png"
      },
      {
        "super_calculate": false,
        "lua_do": "function lua_do()\n    images.nemo.isVisible = false\n    g.image_part_of_screen = 0.3\n    inputText = native.newTextBox(canvas.width / 2, canvas.height / 1.5, canvas.width / 1.2, canvas.height / 3)\n    canvasGroup:insert (inputText)\n    inputText.isEditable = true\n    inputText.placeholder = \"Введите значение...\"\nend",
        "text": "  ",
        "id": 49,
        "calculate": true
      }
    ]
  },
  {
    "id": 50,
    "text": "Введённое значение: ",
    "answers": [
      {
        "id": 50,
        "text": "     ",
        "lua_text": "function lua_text()\n    return text55\nend",
        "merge": true
      },
      {
        "id": 49,
        "text": "Еще раз"
      },
      {
        "id": 51,
        "text": "Посмотреть использованный код"
      },
      {
        "id": 50,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      },
      {
        "id": 50,
        "text": "   \n   Чарлз Дарвин - основоположник теории эволюции путем случайных изменений и естественного отбора.",
        "comment": true,
        "lua_if": "function lua_if()\n    return text55 == \"R2d2\"\nend"
      }
    ]
  },
  {
    "id": 51,
    "text": "   Для того, чтобы полотно, на котором обычно размещаются картинки, появилось, нужно сначала вставить хотя бы одну картинку (любую) обычным образом через кнопку «Добавить картинку».\n   Потом на ответе надо написать имя картинки английскими буквами без использования дефиса и пробелов. Вместо пробела можно использовать символ подчеркивания. Можно в имя добавить цифры, но только не в первой позиции. Для примера я использовал переменную \"nemo\". \n   Если бы я назвал её \"screen1\", то строка имела бы другой вид:\n\n   images.screen1.isVisible = false\n\n   Теперь мы можем добавлять поле. Чтобы на всех устройствах поля отображались одинаково, нужно задавать их в долях размера полотна.\n\n   inputText = native.newTextBox(canvas.width / 2, canvas.height / 2, canvas.width / 1.2, canvas.height / 5)\n\n   Таким образом мы получим размер того самого поля, которое было в примере. Если хотите сузить поле, то смените значение 1.2 на другое, например 3. Чтобы увеличить поле по высоте нужно 5 заменить на меньшее число, например 3.\n   Не бойтесь подставлять различные значения, даже нецелые. В случае ошибки всегда можно исправить всё в режиме автора.\n\n   Теперь вставляем само поле в состав группы полотна: \n\n   canvasGroup:insert (inputText)\n\n   Есть два типа поля: Field и Box. \n   Field удобен тем, что он сам подгоняет шрифт текста под размеры поля, и чем больше информации в нём, тем мельче шрифт будет по итогу.\n   Box имеет стандартный шрифт, и превышение информации просто позволит скролить его вверх-вниз.\n\n   Если использовать Box, а не Field, необходимо вручную включить возможность редактировать это поле:\n\n   inputText.isEditable = true\n\n   Также можно ввести текст-подсказку, который будет отображаться при пустом значении в поле.\n\n   inputText.placeholder = \"Введите значение...\"\n\n   Ну а теперь весь код в одном виде:",
    "answers": [
      {
        "id": 51,
        "text": "   function lua_do()\n       images.nemo.isVisible = false\n       inputText = native.newTextBox(canvas.width / 2, canvas.height / 2, canvas.width / 1.2, canvas.height / 5)\n       canvasGroup:insert (inputText)\n       inputText.isEditable = true\n       inputText.placeholder = \"Введите значение...\"\n   end",
        "comment": true
      },
      {
        "id": 51,
        "text": "На ответе, который сохранит введённый текст в переменную:\n\n   function lua_do()\n       text55 = inputText.text\n       display.remove(inputText)\n   end\n\n   Для примера используется переменная \"text55\".",
        "comment": true
      },
      {
        "id": 49,
        "text": "Еще раз"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 52,
    "text": "   В переменной global standartDialogOptions хранится таблица с теми же параметрами, которые передаются при вызове диалога. Значения из этой таблицы используются при вызове каждого диалогового окна, но если в конкретных диалоговых окнах будет прописано иное, то оно затрёт значение из стандартной настройки.\n\n",
    "answers": [
      {
        "id": 52,
        "text": "   g.standartDialogOptions = {\n       background = \"ссылка.jpg\",\n       answers = {\n           background = \"ссылка.jpg\",\n       }\n   }\n\n   Пример выше меняет стандартный фон диалога и стандартный фон каждого ответа.",
        "merge": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 53,
    "text": "   Модуль Луа.",
    "answers": [
      {
        "module": true,
        "comment": true,
        "super_calculate": false,
        "id": 53,
        "calculate": true,
        "lua_do": "function lua_do()\n<s>r\nvspyshka = function(r,g,b)<s>r\nr = r or 1<s>r\ng = g or 1<s>r\nb = b or 1<s>r\n<s>r\n<s>r\nlocal rect = display.newRect(display.contentCenterX, display.contentCenterY,display.contentCenterX*2, display.contentCenterY*2 )<s>r\n<s>r\ncanvas.parent.parent.parent.parent.parent.parent.parent:insert(rect)<s>r\n<s>r\nrect:setFillColor(r,g,b)<s>r\n<s>r\ntransition.from(rect, {--настройка появления<s>r\n<s>r\ntime = 500,<s>r\n<s>r\nalpha = 0,<s>r\n<s>r\ntransition = easing.outExpo,<s>r\n<s>r\nonComplete = function()<s>r\n<s>r\ntimer.performWithDelay(50, function()--если хочешь подержать белый экран<s>r\n<s>r\nif rect and rect.removeSelf then<s>r\n<s>r\ntransition.to(rect, {--настройка исчезновения<s>r\n<s>r\ntime = 500,<s>r\nalpha = 0,<s>r\ntransition = easing.inExpo,<s>r\nonComplete = function()<s>r\nif rect and rect.removeSelf then<s>r\nrect:removeSelf()<s>r\nrect = nil<s>r\nend<s>r\nend<s>r\n})<s>r\nend<s>r\nend)<s>r\nend<s>r\n})<s>r\n<s>r\nend\nend",
        "text": "luaModuleUpdate http://188.120.236.127/lua/vspyshka.lua"
      },
      {
        "id": 53,
        "text": "Новый ответ. введите текст",
        "comment": false,
        "url": "http://188.120.236.127/lua/vspyshka.lua"
      }
    ]
  },
  {
    "id": 54,
    "text": "   ",
    "answers": [
      {
        "id": 55,
        "text": "Далее"
      },
      {
        "id": 5,
        "text": "В начало"
      },
      {
        "id": 54,
        "text": "Таблицы и массивы — очень удобный механизм хранения однотипных данных. Для создания пустой таблицы или массива нужно только объявить её:\n\n   goldenTable = { }\n\n   Стоит сразу уяснить разницу между таблицами и массивами. С точки зрения данных, они одинаковы, но разница заключается в том, что в массивах хранение и вызов информации осуществляется через индексы (порядковые номера), в то время как в таблицах могут хранится и другие вложенные таблицы.\n\n   Таблица готова к работе. Теперь в неё можно вносить данные, но предварительно я расскажу о предустановленных значениях, то есть о создании \"не пустой\" таблицы.\n\n   goldenTable = { 1, \"два\", name }\n\n   Сейчас вы видели запись в массиве/таблице в разных видах. Если Ты ответственно и с пониманием читал Уроки Луа, то уже должен знать, что в луа-таблицах можно хранить разные типы данных: текст, цифры, переменные, и даже другие таблицы!\n\n   Для внесения значений в уже существующую массив используют \"объявление\" через порядковый номер элемента массива и его новое значение. Для этого нужно использовать соответствующую запись:\n\n   goldenTable[1] = \"первый\"\n\n   Смотрите, порядковый номер (индекс) элемента в массив — [1] — произведёт запись в указанную \"ячейку\". То есть, если бы массив был пустой, то запись была бы новой, но если массив уже был с объявленным значением [1] до этого, то произойдёт перезапись, то есть объявление нового значения текущего элемента массива. Старое значение будет утеряно навсегда, так что важно помнить, что через \"объявление\" нужно чётко понимать что и куда ты собираешься записывать.\n\n   Для внесения записи в таблицу всё проще: оно записывает значение в следующий \"пустой\" элемент таблицы, следуя порядковому номеру. Для этого можно использовать встроенную в приложении функцию table.insert:\n\n   table.insert(goldenTable, 4)\n\n   Данная функция запишет значение \"4\" в таблицу \"goldenTable\". Просто и удобно. Имеющиеся значения никогда не будут затираться, то есть исчезать. \n   \n   Вот пример для внесения нового значения в массив:\n\n   goldenTable[#goldenTable <plus> 1] = 5\n\n   Перед записью значения, просчитается таблица на количество в ней элементов, и производится запись в следующее \"свободное поле\". Таким образом остерегаться потери данных не стоит.",
        "merge": true
      }
    ]
  },
  {
    "id": 55,
    "text": "   Устроим немного практики, дабы наглядно посмотреть работу с таблицей. Объявите пустую таблицу/массив, и внесиье несколько рандом-значений.",
    "answers": [
      {
        "id": 55,
        "text": "   ",
        "comment": true,
        "lua_text": "function lua_text()\n    text = \"\"\n    if not goldenTable then\n        goldenTable = {}\n    end\n    for k in pairs(goldenTable) do\n        if goldenTable[k] then\n        text = text .. goldenTable[k] .. \" / \" end\n    end\n    return text\nend"
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    goldenTable = {}\nend",
        "instant": true,
        "id": 55,
        "text": "Объявить пустую таблицу.\n\nfunction lua_do()\n    goldenTable = {}\nend"
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    table.insert(goldenTable, math.random(0, 9))\nend",
        "instant": true,
        "text": "Внести рандом-значение от 0 до 9.\n\nfunction lua_do()\n    table.insert(goldenTable, math.random(0, 9))\nend",
        "id": 55
      },
      {
        "comment": false,
        "text": "Заменить первое значение на другое рандом-значение.\n\nfunction lua_do()\n    goldenTable[1] = math.random(0, 9)\nend\n\nfunction lua_if()\n    return goldenTable[1]\nend",
        "id": 55,
        "instant": true,
        "lua_do": "function lua_do()\ngoldenTable[1] = math.random(0, 9)\nend",
        "lua_if": "function lua_if()\n    return goldenTable[1]\nend"
      },
      {
        "comment": false,
        "lua_if": "function lua_if()\nreturn goldenTable[2]\nend",
        "id": 55,
        "instant": true,
        "lua_do": "function lua_do()\ngoldenTable[2] = math.random(0, 9)\nend",
        "text": "Заменить второе значение на другое рандом-значение.\n\nfunction lua_do()\n    goldenTable[2] = math.random(0, 9)\nend\n\nfunction lua_if()\n    return goldenTable[2]\nend"
      },
      {
        "comment": false,
        "text": "Поменять местами первое и второе значение.\n\nfunction lua_do()\n    goldenTable[1], goldenTable[2] = goldenTable[2], goldenTable[1]\nend\n\nfunction lua_if()\n    return goldenTable[1] and goldenTable[2]\nend",
        "id": 55,
        "instant": false,
        "lua_do": "function lua_do()\n    goldenTable[1], goldenTable[2] = goldenTable[2], goldenTable[1]\nend",
        "lua_if": "function lua_if()\n    return goldenTable[1] and goldenTable[2]\nend"
      },
      {
        "id": 55,
        "text": "   ",
        "comment": true
      },
      {
        "id": 55,
        "text": "   ",
        "comment": true
      },
      {
        "id": 56,
        "text": "Если всё понятно, то продолжим ",
        "lua_if": "function lua_if()\n    return goldenTable[1]\nend"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 56,
    "text": "   Что ж, теперь рассмотрим несколько моментов с выводом информации из таблицы/массива. В предыдущем примере для вывода содержания таблицы/массива я использовал следующее:\n\nfunction lua_text()\n    text = \"\"\n    if goldenTable then\n        for k in pairs(goldenTable) do\n            if goldenTable[k] then\n                text = text .. goldenTable[k] .. \" / \"\n            end\n        end\n    end\n    return text\nend\n\n   Цикл for — do перебирает все значения в таблице/массиве и выводит данные из неё по нужному и прописанным тобой условиям.\n\n   Зачастую невозможно предсказать количество введенных значений другим пользователем (читателем), так как он может нажать ввод данных три раза, а может и тридцать раз...\n   Но есть функция подсчета. Могу сказать, что в прошлом практическом умении было введено ",
    "answers": [
      {
        "id": 56,
        "text": "    ",
        "lua_text": "function lua_text()\n    return table.count(goldenTable)\nend",
        "merge": true
      },
      {
        "id": 56,
        "text": " значений. Как я узнал, если писал этот материал задолго до Вашего прочтения? Вот так: \n\n   table.count(goldenTable)\n\n   Такая функция вернёт одну цифру, которая будет соответствовать общему количеству записанных значений в таблице/массиве.\n\n   Как это вписать в текст или кнопку ответа? \n\n   function lua_text()\n       return \"Введенное количество значений: \" .. table.count(goldenTable)\n   end\n\n   Данный текст будет выглядеть следующим образом: \"Введенное количество значений: ",
        "merge": true
      },
      {
        "id": 56,
        "text": "    ",
        "lua_text": "function lua_text()\n    return #goldenTable .. '\".'\nend",
        "merge": true
      },
      {
        "id": 56,
        "text": "   — # же считает до последнего пустого элемента.\n   То есть, если в таблица будет иметь пустые ячейки и выглядеть примерно так: { 1, 2, 3, nil, nil, 6, 7 } - то table.count покажет 5 значений, а оператор # покажет 7 значений. \n   Вот такая вот разница.\n\n   Для вывода единичного значения, например в отдельную переменную и рандом, нужно:\n\n   a = goldenTable[1]\nили\n    a = math.random(table.count(goldenTable))",
        "merge": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 57,
    "text": "   Простое сообщение-уведомление. Вот код, и пример, как он работает:\n\n",
    "answers": [
      {
        "comment": false,
        "id": 57,
        "text": "Неверный ответ",
        "lua_do": "function lua_do()\n    local alertShow = native.showAlert(\"Ошибка!\", \"Вы выбрали неверный вариант.\", {\"Ок\"})\nend",
        "no_transition": true
      },
      {
        "comment": false,
        "id": 57,
        "text": "Верный вариант",
        "lua_do": "function lua_do()\n    local alertShow = native.showAlert(\"Всё верно!\", \"Вы выбрали верный вариант и получили <plus>10 к Знаниям.\", {\"Отлично!\"})\nend",
        "no_transition": true
      },
      {
        "id": 57,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "Назад"
      },
      {
        "id": 57,
        "text": "   function lua_do()\n       local alertShow = native.showAlert(\"Ошибка!\", \"Вы выбрали неверный вариант.\", {\"Ок\"})\n   end",
        "merge": true
      }
    ]
  },
  {
    "id": 58,
    "text": "   Прописывая код в разных блоках возникает возможность того, что читатель выйдет на него не в той последовательности действий, как это задумал автор, и оттого может случиться ошибка в коде из-за отсутствующей переменной. \n   Если в операторах Приложения мы напишем var add [\"money\", 10], то ответ пройдет без ошибок, даже если переменная money еще не использовалась — она автоматически создастся и выполнит вписанное в ответе действие.\n   В луа совсем иначе. Состояние переменной \"money = 0\" и \"money = nil\" — разное.\n   Равнение нулю означает, что переменная существует/создаётся, в то время как равнение nil означает стирание переменной и её отсутствие как таковой.\n   Если вы используете в своём коде действие с несуществующей переменной, то сразу получите \"чёрное окно\" — bug report — сообщение об ошибке. Суть этой ошибки нужно искать в последнем предложении этого самого окна с ошибкой. \n   Зачастую там оказывается, что какая-либо переменная не имеет значения (nil), или вы пытаетесь соединить несколько переменным с текстом, одна из которых не имеет значения (nil), или арифметическая ошибка в результате вычисления по записанной автором формуле, так как значение переменной не существует (nil).\n   Как же защититься от подобных ошибок? \n   Грамотнее всего в самом начале кода провести проверку существования переменной. Ведь проще получить на выходе ноль, чем ловить ошибку.\n   Проверка выглядит так:\n   \n   money = money or 0\n\n   То есть, если переменная money существует, то она остаётся без изменений, но если её нет, то она создастся со значением 0.\n   Есть еще один способ проверки, но он по сути такой же, но писать чуточку больше.\n\n   if not money then \n       money = 0 \n   end\nили...\n   if not money then money = 0 end\n\n   Суть такая же — если нет переменной money, то создать её равной 0. \n   Правильнее использовать первый пример с \"or\", но каждому своё, и это вопрос удобства. Оба примера эквивалентны друг другу.",
    "answers": [
      {
        "id": 59,
        "text": "Пример кода с проверкой"
      },
      {
        "id": 5,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 59,
    "text": "   function lua_do()\n       money = money or 0\n       apple = apple or 0\n       if money < 50 then\n             message(\"Не хватает денег на покупку!\")\n       else\n           apple = apple <plus> 1\n           money = money — 50\n       end\n   end\n",
    "answers": [
      {
        "id": 5,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 60,
    "text": "   Локальные переменные — это вид переменных, хранящихся строго в одной функции, которые не сохраняются в общий список переменных.\n\n   function lua_text()\n       local a = math.random(10)\n       return a\n   end\n\n    Такой код покажет просто одну цифру, которую даст рандом. Эту цифру невозможно использовать в другом коде.\n\n   Если у вас уже существует переменная \"а\", то при объявлении local a, далее по коду, будет использоваться локальное значение переменной \"а\". Во избежание путаницы рекомендуем избегать подобного задваивания.\n   \n   Вот еще один пример.\n  \n   function lua_do()\n       local a = 5\n       local b = 30\n       local c = math.random(3)\n       d = (b / a) — c\n   end\n\n   Три локальных переменных a, b, c — не сохранятся, в то время как переменная d имеет глобальное значение, и сохранится в списке переменных.\n   Вот еще пример.\n\n   function lua_text()\n   ",
    "answers": [
      {
        "id": 60,
        "text": "    local books = { \"Рапунцель\", \"Золушка\", \"Спасящая красавица\", \"Белоснежка\", \"Красная шапочка\" }\n       return \"Вы взяли с полки книжку с названием: \" .. books[math.random(#books)]\n   end\n\n   Кнопка ниже представляет данный пример.",
        "merge": true
      },
      {
        "comment": false,
        "id": 60,
        "text": "    ",
        "instant": true,
        "lua_text": "function lua_text()\n    local books = {\"Рапунцель\", \"Золушка\", \"Спасящая красавица\", \"Белоснежка\", \"Красная шапочка\"}\n   return \"Вы взяли с полки книжку с названием: \" .. books[math.random(#books)]\nend"
      },
      {
        "id": 60,
        "text": "  ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 61,
    "text": "   ",
    "answers": [
      {
        "id": 61,
        "text": "Widget - библиотека фреймворка Corona, предоставляющая возможность удобно создавать кнопки, слайдеры (или просто, ползунки) и другие элементы пользовательского интерфейса.\n\n   Слайдер (ползунок).\nДля начала работы с библиотекой widget ее нужно подключить:\n\n   function lua_do()\n       widget = require(\"widget\")\n   end\n\n   Теперь функции из этой библиотеки можно вызывать по всему квесту, не подключая её каждый раз.\n\n   Рассмотри принцип работы на конкретном примере:\n\n   function lua_do()\n       myslider = widget.newSlider{\n           x = display.contentCenterX,\n           y = display.contentCenterX,\n           width = 400,\n           value = 0\n       }\n   end\n\n   Давай разберемся, что тут написано.\n\n   myslider = widget.newSlider\n  \n   Эта строка говорит, что мы создаём ползунок с именем myslider.\n   Далее идут фигурные скобки. Передаем в качестве аргумента таблицу, в которой есть следующие поля:\n   x - определяет место, в котором ползунок будет находиться по оси Х.\n   y - то же, что и Х, для координаты У. \n   (Я для примера установил эти значения как центр экрана по Х)\n   width - ширина ползунка (только для горизонтального).\n   value - изначальное значение ползунка.\n\n   Но в эту таблицу можно передать и другие поля:\n   left и top - положение ползунка слева и сверху. Заменяют собой Х и У.\n   orientation - ориентация ползунка. Вертикальная (\"vertical\") или горизонтальная (\"horizontal\"). По умолчанию - горизонтальная.\n   height - высота ползунка (только для вертикального).\n   listener - функция для обработки действий с ползунком. \n   У ползунка есть фазы: began - когда движение ползунка началось, moved - когда ползунок в движении или пользователь держит на нем палец, и ended - когда движение закончено.\n   С помощью функции обработки и фаз ползунка можно получить текущее значение слайдера.\n\nСледующий код создаст слайдер и запишет его значение в переменную val когда фаза - \"движение\":\n\n   function lua_do()\n       myslider = widget.newSlider{\n           x = display.contentCenterX,\n           y = display.contentCenterX,\n           width = 400,\n           value = 0,\n           listener = function(event)\n              if event.phase == \"moved\" then\n                  val = event.value\n             end\n          end\n       }\n   end\n\n   Далее создадим ещё ответ, в котором используем функцию lua_text для отображения результата:\n\n   function lua_text()\n       return val\n   end\n\n   Добавим встроенный в «Текстовые Квесты» оператор update, чтобы весь код обновлялся. В квадратных скобках укажем 0.1. Мы получили, что каждые 100 миллисекунд lua_text будет обновляться, отражая реальное значение слайдера.",
        "merge": true
      },
      {
        "id": 62,
        "text": "Практический пример"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 62,
    "text": "   ",
    "answers": [
      {
        "super_calculate": false,
        "lua_do": "function lua_do()\n    widget = require(\"widget\")\n    myslider = widget.newSlider{\n        x = display.contentCenterX,\n        y = 200,\n        width = 400,\n        value = 0,\n        listener = function(event)\n            if event.phase == \"moved\" then\n                val = event.value\n            end \n         end\n    }\nend",
        "text": "   ",
        "calculate": true,
        "id": 62
      },
      {
        "id": 62,
        "text": "  ",
        "comment": true
      },
      {
        "var_show": [
          "val"
        ],
        "comment": true,
        "id": 62,
        "text": "Значение val:",
        "update": [
          0.1
        ]
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 63,
    "text": "    ",
    "answers": [
      {
        "id": 63,
        "text": "Спервая я вам покажу простой пример выбора случайного значения из нескольких значений, которые между собой никак не связаны последовательностью. Например: 1, 5, 10.\n\n   x = { 1, 5, 10 }\n   a = x[math.random(#x)]\n\n   То есть, в массив (таблицу) \"х\" записываются значения 1, 5 и 10. Далее переменной \"а\" присваивается значение, согласно выпавшему случайному номеру-индексу.\n   То есть, запись math.random( #x ) считывает количество записей, а их в массиве \"х\" записано всего три, и далее рандом выдает случайное значение от 1 до 3.\n   Если в массив дописать еще два значения, то код всё равно будет работать, так как \"#х\" всегда будет проверять количество записей в массиве \"х\", и при пяти записях выдаст номер от 1 до 5.\n    Далее, \"а = х[ _полученный рандомом номер_ ]\" работает как определение записанного значения в массиве по порядковому номеру. Например, выпадает 2, и в переменную \"а\" запишется значение под номером 2 из массива (а именно 5).",
        "merge": true
      },
      {
        "lua_text": "function lua_text()\n    return a and (\"Выпало: \" .. a) or \"Нажмите на ответ\"\nend",
        "comment": false,
        "id": 63,
        "text": "   ",
        "lua_do": "function lua_do()\n    x = { 1, 5, 10 }\n    a = x[math.random(#x)]\nend",
        "instant": true
      },
      {
        "id": 63,
        "text": "  ",
        "comment": true
      },
      {
        "id": 64,
        "text": "Функции для рандома",
        "lua_do": "function lua_do()\n    a = nil\nend"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 64,
    "text": "   Профессиональным способом считается написание функции, для её дальнейшего использования в коде в любой нужный момент.\n\n",
    "answers": [
      {
        "id": 64,
        "text": "   function RandomFrom(...)\n       return arg[math.random(arg.n)]\n   end\n\n   Далее эту функцию можно использовать так:\n\n   a = RandomFrom(1, 5, 10)\n\n   Принцип работы тот же самый, но к функции можно обратить когда и где угодно, указав только аргументы (значения).",
        "comment": false,
        "merge": true
      },
      {
        "super_calculate": false,
        "lua_do": "function lua_do()\n    function RandomFrom(...)\n        return arg[math.random(arg.n)]\n    end\nend",
        "text": "     \n\n",
        "calculate": true,
        "id": 64
      },
      {
        "lua_text": "function lua_text()\n    return a and (\"Выпало: \" .. a) or \"Нажмите на ответ\"\nend",
        "comment": false,
        "id": 64,
        "text": "Новый ответ. введите текст",
        "lua_do": "function lua_do()\n    a = RandomFrom(1, 5, 10)\nend",
        "instant": true
      },
      {
        "id": 64,
        "text": "   ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 65,
    "text": "   Запишите вот эту опцию:\n\n   date = os.date( \"*t\" )\n\n   И теперь переменная \"date\" является таблицей,  содержащей данные по дате устройства, которые будут верны на момент проведения расчётов.\n\n   Содержание таблицы date: \nyear (текущий год),\nmonth (1-12),\nday (1-31),\nhour (0-23),\nmin (0-59),\nsec (0-59),\nwday (день недели, где воскресенье = 1, а суббота = 7),\nyday (текущий день по счёту из 365),\nisdst (не знаю что это, но содержит булиное значение true/false).\n\n   Вот вам выведена информация и поставлена на update[1]:",
    "answers": [
      {
        "lua_text": "function lua_text()\n    local date = os.date(\"*t\")\n    return \"Год: \" .. date.year .. \"<s>\nМесяц: \" .. date.month ..\"<s>\nДень: \" .. date.day .. \"<s>\nЧас: \" .. date.hour .. \"<s>\nМинуты: \" .. date.min .. \"<s>\nСекунды: \" .. date.sec .. \"<s>\nДень недели: \" .. date.wday .. \"<s>\nДень в году: \" .. date.yday\nend",
        "comment": true,
        "super_calculate": false,
        "id": 65,
        "text": "   ",
        "update": [
          1
        ],
        "calculate": false
      },
      {
        "calculate": false,
        "comment": true,
        "super_calculate": false,
        "id": 65,
        "text": "   ",
        "update": [
          1
        ],
        "lua_text": "function lua_text()\n    local date = os.date(\"*t\")\n    return \"Или в другом формате можно сделать:<s>\n<s>\n\" .. \"Дата: \" .. date.day .. \"/\" .. date.month ..\"/\" .. date.year .. \"<s>\nВремя: \" .. date.hour .. \":\" .. date.min .. \":\" .. date.sec .. \"<s>\nДень недели/года: \" .. date.wday .. \"/\" .. date.yday\nend"
      },
      {
        "id": 65,
        "text": "   ",
        "comment": true
      },
      {
        "id": 66,
        "text": "Код для вывода информации из таблицы date"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 66,
    "text": "   Первый вариант: ",
    "answers": [
      {
        "id": 66,
        "text": "   update[1]\n\n   function lua_text()\n       local date = os.date(\"*t\")\n       return \"Год: \" .. date.year .. \"<s>\nМесяц: \" .. date.month ..\"<s>\nДень: \" .. date.day .. \"<s>\nЧас: \" .. date.hour .. \"<s>\nМинуты: \" .. date.min .. \"<s>\nСекунды: \" .. date.sec .. \"<s>\nДень недели: \" .. date.wday .. \"<s>\nДень в году: \" .. date.yday\n   end",
        "comment": true
      },
      {
        "id": 66,
        "text": "\nВторой вариант:",
        "comment": true
      },
      {
        "id": 66,
        "text": "   update[1]\n\n   function lua_text()\n       local date = os.date(\"*t\")\n       return \"Дата: \" .. date.day .. \"/\" .. date.month ..\"/\" .. date.year .. \"<s>\nВремя: \" .. date.hour .. \":\" .. date.min .. \":\" .. date.sec .. \"<s>\nДень недели/года: \" .. date.wday .. \"/\" .. date.yday\n   end",
        "comment": true
      },
      {
        "id": 66,
        "text": "   ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 67,
    "text": "   Выводя текст, иногда эстетичнее бывает отразить его с новой строки, или даже с красной строки. Но как добиться этого эффекта? \n   Вот пример записи:\n\n   function lua_text()\n       return \"Нужно купить:<s>\n—Морковь,<s>\n—Картофель.\"\n   end\n\n   А вот как это будет выглядеть для читателя:\n\nНужно купить:\n—Морковь, \n—Картофель.\n\n   Давайте наведём красоту в отображении?\n\n   function lua_text()\n       return \"   Нужно купить:<s>\n   — Морковь,<s>\n   — Картофель.\"\n   end\n\n   Теперь выведенный текст будет выглядеть следующим образом:\n\n   Нужно купить:\n   — Морковь, \n   — Картофель. \n\n   Все пробелы выставляются ровно в том количестве, как и указано в самом коде, а сама конструкция \"<s>\n\" заменяется на перенос строки, не меняя остального текста на выводе.",
    "answers": [
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 68,
    "text": "   Есть стандартная функция table.sort, которая призвана отсортировать по возрастанию все значения в массиве (от меньшего к большему). Этот порядок можно изменить, задав противоположное условие, и тогда таблица будет отсортирована по убыванию (от большего к меньшему).\n   Для начала рассмотрим стандартную функцию.",
    "answers": [
      {
        "comment": false,
        "lua_do": "function lua_do()\n    tableA = { 3, 5, 1, 2, 4 }\nend",
        "text": "Создать массив\n\nfunction lua_do()\n    tableA = { 3, 5, 1, 2, 4 }\nend",
        "lua_if": "function lua_if()\n    return not tableA\nend",
        "id": 68
      },
      {
        "lua_text": "function lua_text()\n    return \"Появился массив со значениями. До обработки он выглядит так: 3, 5, 1, 2, 4. Давайте проведём сортировку и посмотрим результат.\"\nend",
        "id": 68,
        "text": "    ",
        "lua_if": "function lua_if()\n    return tableA\nend",
        "comment": true
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\n    sorted = true\n    table.sort(tableA)\nend",
        "text": "Сортировать массив\n\nfunction lua_do()\n    table.sort(tableA)\nend",
        "lua_if": "function lua_if()\n    return tableA and not sorted\nend",
        "id": 68
      },
      {
        "id": 68,
        "text": "\nКак видим, значения в массиве выстроились по возрастанию.",
        "comment": true,
        "lua_if": "function lua_if()\n    return sorted\nend"
      },
      {
        "lua_if": "function lua_if()\n    return tableA\nend",
        "id": 68,
        "text": "   ",
        "comment": true,
        "lua_text": "function lua_text()\n    return \"Значения массива по порядку: \" .. table.concat(tableA, \", \")\nend"
      },
      {
        "id": 69,
        "text": "Далее, сортировка по убыванию"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 69,
    "text": "   Для получения сортировки по убыванию необходимо дописать небольшую локальную функцию, чтобы сортировка прошла так, как нужно. \n   Важно помнить, что тип значений в массиве должен быть одинаковым. Не допускается сравнение цифр и текста, которое приводит к ошибке и вылету из программы. ",
    "answers": [
      {
        "id": 69,
        "text": "Сортировка по убыванию\n\nfunction lua_do()\n    local function compare(a, b)\n        return a > b\n    end\n    table.sort(tableA, compare)\nend",
        "comment": false,
        "lua_do": "function lua_do()\n    local function compare(a, b)\n        return a > b\n    end\n    table.sort(tableA, compare)\nend"
      },
      {
        "lua_text": "function lua_text()\n    return \"Значения массива по порядку: \" .. table.concat(tableA, \", \")\nend",
        "id": 69,
        "text": "   ",
        "lua_if": "function lua_if()\n    return tableA\nend",
        "comment": true
      },
      {
        "id": 70,
        "text": "Другие примеры с текстовыми значениями"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 70,
    "text": "   ",
    "answers": [
      {
        "super_calculate": false,
        "id": 70,
        "calculate": false,
        "lua_do": "function lua_do()\n    tableA = {\"зелёный\", \"белый\", \"синий\", \"жёлтый\", \"красный\"}\nend",
        "text": "Создать массив с текстовыми значениями\n\nfunction lua_do()\n    tableA = {\"зелёный\", \"белый\", \"синий\", \"жёлтый\", \"красный\"}\nend"
      },
      {
        "id": 70,
        "text": "Сортировать по возрастанию\n\nfunction lua_do()\n    table.sort(tableA)\nend",
        "comment": false,
        "lua_do": "function lua_do()\n    table.sort(tableA)\nend"
      },
      {
        "id": 70,
        "text": "Сортировать по убыванию\n\nfunction lua_do()\n    local function compare(a, b)\n        return a > b\n    end\n    table.sort(tableA, compare)\nend",
        "comment": false,
        "lua_do": "function lua_do()\n    local function compare(a, b)\n        return a > b\n    end\n    table.sort(tableA, compare)\nend"
      },
      {
        "comment": true,
        "id": 70,
        "text": "   ",
        "lua_text": "function lua_text()\n    return \"Значения массива по порядку: \" .. table.concat(tableA, \", \")\nend",
        "lua_if": "function lua_if()\n    return tableA\nend"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 71,
    "text": "Прежде чем приступить к коду, немного описания того, что из себя представляет \"var random from weight\".\n    Оператор \"var random from weight\" выдаёт случайное значение из списка с указанной вероятностью. Например:\nvar random from weight[\"a\", 0, 25, 1, 75]\n    В переменную \"a\" будет записано 0 с вероятность в 25 и 1 с вероятностью в 75. Для вероятности можно вписывать абсолютно любое целое число, которое больше 0.\n\nА теперь реализация на lua. Сама функция будет отличаться от оператора \"var random from weight\" тем, что можно будет указывать не только целочисленную, но и дробную вероятность.\n\nfunction RandomFromWeight(...)\n    local weight = 0.0\n    for i = 2, arg.n, 2 do\n        weight = weight <plus> arg[i]\n    end\n    weight = weight * math.random()\n    for i = 2, arg.n, 2 do\n        weight = weight — arg[i]\n        if (weight <= 0)\n        then\n            return arg[i — 1]\n        end\n    end\nend\n\nПосле объявления, эту функцию можно вызвать так:\na = RandomFromWeight(0, 25, 1, 75)\n\nПояснение к коду:\nfunction RandomFromWeight(...)\n—- Объявление функции. Вместо параметров здесь указано \"...\", это значит, что функция будет принимать произвольное число параметров, т.е. при вызове можно указать столько параметров, сколько Вам необходимо. В таблице \"arg\" будут храниться все переданные аргументы. А в arg.n хранится число параметров.\nlocal weight = 0.0\n—- Объявление локальной переменной, которая будет хранить в себе сумму вероятностей.\nfor i = 2, arg.n, 2 do\n—- Цикл, который будет перебирать значения начиная со второго индекса и с итерацией в 2 шага, так как по каждому второму индексу будет храниться вероятность. В arg.n хранится число переданных аргументов.\nweight = weight <plus> arg[i]\n—- Прибавление к сумме вероятностей.\nweight = weight * math.random()\n—- В \"weights\" записывается случайное дробное число. math.random() генерирует случайное Дробное число от 0 до 1. После чего это умножается на сумму вероятностей. На выходе получается какое-то случайное дробное число в пределах от 0 до weights (суммы вероятностей).\nfor i = 2, arg.n, 2 do\n—- Вновь цикл для перебора всех вероятностей.\nweight = weight — arg[i]\n—- От случайно выданного ранее числа отнимается вероятность.\nif (weight <= 0)\n—- Если после этого число меньше или равно 0.\nreturn arg[i — 1]\n—- То нужно вернуть аргумент, который соответствует данному весу.\n\nПример того, как может работать функция.\n1) Передали 4 параметра (15, \"a\", 25, \"b\").\n2) Сложили все вероятности (15 <plus> 25 = 40)\n3) Выдали рандомное дробное число от 0 до 40. Например, 16.5\n4) По циклу от этого числа отнимается каждая вероятность.\n    16.5 — 15 = 1.5\n5) Проверяется, меньше или равно ли число после этого. В данном случае 1.5 > 0. Ничего не меняется и цикл повторяется вновь. Отнимается следующая вероятность (1.5 — 25 = -23.5). Проверяется, меньше или равно ли число 0. В данном случае -23.5 <= 0, условие выполняется и возвращается аргумент с текущим индексом от данной вероятности (\"b\").\nЕсли бы выпало число меньшее или равно 15, то функция бы вернула \"a\".",
    "answers": [
      {
        "id": 71,
        "text": "Show var",
        "lua_text": "function lua_text()\n    if (type(RandomFromWeight) ~= \"function\")\n    then\n        function RandomFromWeight(...)\n            local weight = 0.0\n            for i = 2, arg.n, 2 do\n                weight = weight <plus> arg[i]\n            end\n            weight = weight * math.random()\n            for i = 2, arg.n, 2 do\n                weight = weight - arg[i]\n                if (weight <= 0)\n                then\n                    return arg[i - 1]\n                end\n            end\n        end\n    end\n    return \"var = \" .. (var or 0)\nend",
        "comment": true
      },
      {
        "id": 71,
        "text": "var = RandomFromWeight(\"low\", 25, \"standart\", 50, \"high\", 100, \"very high\", 150)",
        "lua_do": "function lua_do()\n    var = RandomFromWeight(\"low\", 25, \"standart\", 50, \"high\", 100, \"very high\", 150)\nend",
        "instant": true
      },
      {
        "id": 71,
        "text": "var = RandomFromWeight(\"first\", 100, \"second\", 100)",
        "lua_do": "function lua_do()\n    var = RandomFromWeight(\"first\", 100, \"second\", 100)\nend",
        "instant": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 72,
    "text": "math.random используется для генерации случайных чисел. Обычно, его вызывают для генерации каких-нибудь целых чисел, указав при этом пределы.\n    К примеру: math.random(6) выдаст случайное число от 1 до 6, math.random(3, 8) выдаст случайное число от 3 до 8.\n    Но если же в функцию не передавать параметров, то она вернёт случайное Дробное число от 0.0 до 1.0. Это может быть 0.519283, 0.12424, 0.78789, 0.91, 0.12 и т.д.\n    Для генерации случайного дробного числа от 0 до 6 можно использовать следующий код:\nvar = math.random() * 6.0\n    К примеру, если math.random() выдаст 0.54, то в \"var\" будет записано 0.54 * 6.0 = 3.24.\n    Можно сделать и рандом от какого-нибудь числа, например, от 3 до 7:\nvar = math.random() * 4.0 <plus> 3.0\n    Сначала будет сгенерировано случайное дробное число от 0 до 4, а затем к нему прибавится 3.\nФункцию для рандома дробных чисел можно оформить так:\n\nfunction RandomReal(min, max)\n    if (not max)\n    then\n        max = min\n        min = 0\n    end\n    return (max — min) * math.random() <plus> min\nend\n\nИли так:\n\nfunction RandomReal(min, max)\n    return (max and max — min or min) * math.random() <plus> (max and min or 0)\nend",
    "answers": [
      {
        "id": 72,
        "text": "Show var",
        "lua_text": "function lua_text()\n    if (type(RandomReal) ~= \"function\")\n    then\n        function RandomReal(min, max)\n            return (max and max - min or min) * math.random() <plus> (max and min or 0)\n        end\n    end\n    return \"var = \" .. (var or 0.0)\nend",
        "comment": true
      },
      {
        "id": 72,
        "text": "-- Пример работы \"math.random\" без аргументов. Выдаёт случайное число от 0.0 до 1.0\nvar = math.random()",
        "instant": true,
        "lua_do": "function lua_do()\n    var = math.random()\nend"
      },
      {
        "id": 72,
        "text": "-- Случайное число от 0.0 до 6,0\nvar = math.random() * 6.0",
        "lua_do": "function lua_do()\n    var = math.random() * 6.0\nend",
        "instant": true
      },
      {
        "id": 72,
        "text": "-- Случайное число от 3.0 до 7.0\nvar = math.random() * 4.0 <plus> 3.0",
        "instant": true,
        "lua_do": "function lua_do()\n    var = math.random() * 4.0 <plus> 3.0\nend"
      },
      {
        "id": 72,
        "text": "-- Случайное число от -100.0 до 100.0\nvar = RandomReal(-100.0, 100.0)",
        "lua_do": "function lua_do()\n    var = RandomReal(-100.0, 100.0)\nend",
        "instant": true
      },
      {
        "id": 72,
        "text": "-- Случайное число от 0.0 до 100.0\n-- Оставляет лишь 3 цифры после запятой\nvar = math.floor(RandomReal(100.0) * 1000) * 0.001",
        "instant": true,
        "lua_do": "function lua_do()\n    var = math.floor(RandomReal(100.0) * 1000) * 0.001\nend"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 73,
    "text": "Текст пишется...",
    "answers": []
  },
  {
    "id": 74,
    "text": "   Глобальные переменные хранятся в памяти телефона. Их можно использовать в любой части кода, даже в совершенно другой функции и на другой странице, так как они сохранены в списке переменных.\n   Так как у нас программирование связано с возможностями Текстовых Квестов, то тут есть некая возможность. Все переменные хранятся в списке до тех пор, пока чититель/игрок не завершит его чтение/прохождение и не выйдет на первую страницу квеста. Простой возврат клавишей \"назад\", или нажатие в боковом меню перехода к первой странице, не считается завершение квеста, а является своеобразной паузой.\n   При завершении квеста список переменных обнуляется, но есть одна таблица, которая хранит переменные даже после обнуления — global. Вот два типа обращения к ней:\n\n   var set [\"global money\", 10]    — через операторы Текстовых квестов\n\n       или... \n\n   g.money = 10    — через код луа\n\n   Теперь важно понять, что переменная money и g.money —  разные переменные. Если перейдёте к Практике, то наглядно увидете это.\n   Все переменные, которые записаны в таблице глобал не стираются, поэтому их можно использовать для отслеживания достижений игрока. ",
    "answers": [
      {
        "id": 75,
        "text": "Практика"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 75,
    "text": "   Управляйте кнопками. ",
    "answers": [
      {
        "lua_text": "function lua_text()\nmoney = money or 0\ng.money = g. money or 0\nreturn \"money: \".. money.. \"<s>\ng.money: \".. g. money\nend",
        "middle_answer": true,
        "text": "Новый ответ. введите текст",
        "id": 75,
        "comment": true
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\nmoney = money <plus> 5\nend",
        "id": 75,
        "text": "<plus>5 к money",
        "instant": true,
        "left_answer": true
      },
      {
        "right_answer": true,
        "comment": false,
        "id": 75,
        "instant": true,
        "lua_do": "function lua_do()\ng.money = g.money <plus> 5\nend",
        "text": "<plus>5 к g.money"
      },
      {
        "comment": false,
        "lua_do": "function lua_do()\nmoney = g.money\nend",
        "id": 75,
        "instant": true,
        "text": "money = g.money",
        "left_answer": true
      },
      {
        "right_answer": true,
        "comment": false,
        "id": 75,
        "instant": true,
        "lua_do": "function lua_do()\ng.money = money\nend",
        "text": "g.money = money"
      },
      {
        "id": 75,
        "text": "   ",
        "comment": true
      },
      {
        "comment": false,
        "lua_do": "function lua_do() \nmoney = 0\nend",
        "id": 75,
        "instant": true,
        "text": "money = 0",
        "left_answer": true
      },
      {
        "right_answer": true,
        "comment": false,
        "id": 75,
        "instant": true,
        "lua_do": "function lua_do() \ng.money = 0\nend",
        "text": "g.money = 0"
      },
      {
        "id": 75,
        "text": "   ",
        "comment": true
      },
      {
        "id": 74,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 76,
    "text": "   ",
    "answers": [
      {
        "id": 76,
        "text": "nemo",
        "url": "http://188.120.236.127/hc/island/treasure.png"
      },
      {
        "super_calculate": false,
        "lua_do": "function lua_do()\nimages.nemo.isVisible = false\ng.image_part_of_screen = 0.1\n\nlocal widget = require( \"widget\" )\n\n   local tabButtons = {\n   {label = \"Обновить\", labelColor = {default = {1,0,0}, over = {0,1,0}}, selected = true, size = 25, onPress = function() showPage {id = 76, transition = \"instant\"} end},\n   {label = \"Уведомление\", labelColor = {default = {1,0,0}, over = {0,1,0}}, size = 25, onPress = function() local expNum = native.showAlert(\"Уведомление\", \"Вы нажали вторую вкладку.\", {\"ОК\"}) end},\n   {label = \"В начало\" , labelColor = {default = {1,0,0}, over = {0,1,0}}, size = 25, onPress = function() showPage {id = 5, transition = \"instant\"} end}}\n\nlocal tabBar = widget.newTabBar(\n   {top = displayCenterX,\n   width = displayCenterY,\n   height = 90,\n   color = {0,0,0},\n   tabColor = {0,0,0},\n   buttons = tabButtons})\nend",
        "calculate": true,
        "text": "Новый ответ. введите текст",
        "id": 76
      },
      {
        "id": 76,
        "text": "   Вверху появились три кнопки. Это виджет, который можно настроить. Его код будет представлен на другой странице, а сейчас я хотел бы рассказать о его возможностях.\n   Виджет цельный и настраивается по высоте и ширине. Количество кнопок тоже настраивается, но по умолчанию их размер одинаковый и в сумме занимает всё пространство самого виджета.\n   Нажатие кнопки исполняет написанный в его функции код. Это может быть переход на другую страницу, вывод диалогового окна или предупреждения, исполнение каких-либо сложных функций или расчётов. Каждая кнопка может иметь свою функцию, вне зависимости от других. ",
        "comment": true,
        "merge": true
      },
      {
        "id": 77,
        "text": "Практика"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 77,
    "text": "   ",
    "answers": [
      {
        "id": 77,
        "text": "   function lua_do()\n   images.nemo.isVisible = false\n   g.image_part_of_screen = 0.1\n\n   local widget = require( \"widget\" )\n\n   local tabButtons = {\n      {label = \"Обновить\", \n      labelColor = {\n         default = {1,0,0}, \n         over = {0,1,0}}, \n      selected = true, \n      size = 25, \n      onPress = function() \n         showPage {id = 5, transition = \"instant\"} \n      end},\n\n      {label = \"Уведомление\", \n      labelColor = {\n         default = {1,0,0}, \n         over = {0,1,0}}, \n      size = 25, \n      onPress = function()\n         local expNum = native.showAlert (\"Уведомление\", \"Вы нажали вторую вкладку.\", {\"ОК\"}) \n      end},\n\n      {label = \"В начало\" ,\n      labelColor = {\n         default = {1,0,0}, \n         over = {0,1,0}}, \n      size = 25, \n      onPress = function() \n         showPage {id = 2, transition = \"instant\"} \n      end}}\n\n   local tabBar = widget.newTabBar(\n      {top = displayCenterX,\n      width = displayCenterY,\n      height = 90,\n      color = {0,0,0},\n      tabColor = {0,0,0},\n      buttons = tabButtons})\n   end",
        "comment": true
      },
      {
        "id": 77,
        "text": "\n   Теперь давайте разберём этот пример.\n   Прежде всего нужно развернуть canvas, а для этого нужно добавить картинку на страницу. Для этого нужно нажать на соответствующую кнопку внизу страницы. Вставляем ссылку и картинка добавляется. Появившийся ответ со ссылкой на картинку нужно както обозвать для идентификации. Я всегда использую слово nemo. \n   Сама картинка нам не нужно, поэтому нужно её спрятать. Именно здесь пригодится идентификатор ответа. Я называл её nemo, поэтому пишу следующее:\n\n   images.nemo.isVisible = false\n   \n   Картинка исчезает и не показывается, но при этом поле canvas открыто. Так как оно большое по умолчанию, а сам виджет узкий - я сжимаю это поле. Если его не сжать, то текст и ответы будут далеко внизу экрана телефона. \n\n   g.image_part_of_screen = 0.1\n\n   Поле канваса всегда квадрат, где высота определяется шириной экрана (узкой частью экрана). Предыдущией командой мы сжали поле до 10%. На деле, вы можете ставить любоезначение от 0 до 1, где 0 - исчезновение, а 1 - максимально развёрнутое поле. \n\n   Нужно написать таблицу с настройками кнопок, прежде чем объявить виджет. Для этих целей используем tabButtons.\n\n      {label = \"Обновить\", \n      labelColor = {\n         default = {1,0,0}, \n         over = {0,1,0}}, \n      selected = true, \n      size = 25, \n      onPress = function() \n         showPage {id = 5, transition = \"instant\"} \n      end},\n\n   Этот кусок задаёт именно одну кнопку и её функцию. Если вписать три таких друг за другом, то будет три кнопки. Если пять таких, то будет пять кнопок.\n\n      {label = \"Обновить\" \n      - определяет название кнопки, то, что будет видеть читатель. \n\n      labelColor = {\n         default = {1,0,0}, \n         over = {0,1,0}} \n      - настройка цвета кнопки, где default - обычное состояние кнопки, а over - выбранное. Для примера, я обычное состояние ставил на \"красный текст\", а в выбранном/нажатом - \"зелёный текст\". \n\n      selected = true \n      - это нужно писать только в одной кнопке, которая будет иметь статус \"выбранной/нажатой\". Если нигде не написать, то по умолчанию будет первая кнопка считаться нажатой. \n\n      size = 25\n      - размер текста. \n\n      onPress = function() \n         showPage {id = 5, transition = \"instant\"} \n      end} \n      - функция или код, который будет выполнен после нажатия на кнопку. \n\n   Теперь Остаётся только вызвать виджет с настройкой.\n\n   local tabBar = widget.newTabBar(\n      {top = displayCenterX,\n      width = displayCenterY,\n      height = 90,\n      color = {0,0,0},\n      tabColor = {0,0,0},\n      buttons = tabButtons})\n\n   Более детально:\n   local tabBar = widget.newTabBar(\n   - вызов виджета, которому для запуска нужны определённые данные. \n\n      {top = displayCenterX,\n      width = displayCenterY,\n      height = 90,\n      - определяют центр виджета, его ширину и высоту. \n\n      color = {0,0,0},\n      tabColor = {0,0,0},\n      - тут должен быть цвет виджета и самих кнопок, но я не пробовал их менять. \n\n      buttons = tabButtons})\n      - записывает кнопки с их количеством для создания виджета с правильным числом кнопок и ихфункциями. ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 78,
    "text": "   Есть такие системные функции, которые возвращают максимальное или минимальное значение из вписанных в них переменных. Вот пример:\n\n   a1 = math.max (1, 5, 2)\n   a2 = math.min (1, 5, 2)\n\n   В результате a1 = 5, a2 = 1. То есть внутри функции сравниваются все значения и выводится нужный результат.\n   Примечательно и то, что вместо цифр можно вписать и переменные, и значения массива, и значения таблиц, и формулы. \n\n   a1 = math.max (card, 5, myTab[1])\n   a2 = math.min (-1, card.width, 4 * a1 / 0.8)\n  \n   Теперь покажу вам более конкретный пример. Работая с картинками, которые могут иметь разные размеры и соотношения, а именно вертикальные и горизонтальные, можно получать их большую или меньшую величину такими функциями, не смотря на то, что заранее не известно, какая у картинки самая большая величина (высота или ширина). \n\n   a1 = math.max (card.height, card.width)\n\n   Такая функция вернёт самое большое число, будь то высота или ширина. ",
    "answers": [
      {
        "id": 5,
        "text": "Назад"
      }
    ]
  },
  {
    "id": 79,
    "text": "   Как бы это не казалось сложным — на самом деле это довольно просто: добавить картинку, назначить ей точки местоположения и настроить размер. Теперь подробнее... \n   Каждая картинка обладает перечнем значений, и основные из них мы сейчас рассмотрим. Но, чтобы картинка появилась на страницах наших квестов, нам нужно её добавить. Разработчиком уже продуман весь механизм добавления картинок: в режиме Автора на странице есть кнопка \"Добавить картинку\". Как только вы выставите туда ссылку на картинку, которая заканчивается расширением файла, типа \"ссылка.jpg\" или \"ссылка.png\", станете владельцем этой картинки в квесте.\n   Вот, картинка появилась на экране. Но что с ней делать?\n   У всех картинок есть основные параметры:\n\n   width — ширина,\n   height — высота, \n   xScale — сжатие по координате Х, \n   yScale — сжатие по координате Y, \n   x — местоположение по координате X, \n   y — местоположение по координате Y. \n\n   Как же с ними взаимодействовать? Тут есть два варианта, в зависимомти от используемого вами режима: простой квестовый или полноэкранный. ",
    "answers": [
      {
        "id": 80,
        "text": "Простой режим"
      },
      {
        "id": 81,
        "text": "Полноэкранный режим (fullscreen) "
      },
      {
        "id": 79,
        "text": "   ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В меню",
        "comment": false
      }
    ]
  },
  {
    "id": 80,
    "text": "   Картинка масштабируется и не привышает размера 1000х1000 пикселей. При этом, если ширина экрана игрока меньше 1000 пикселей, то за основу ширины берётся значенип игрока. А привышение 1000 пикселей по ширине приводит к тому, что картинка будет отмасштабирована под 1000, не более.\n   Канвас (в переводе с английского — \"холст\", ударение на второй слог) размещает в себе все добавляемые изображения на странице. Обычно, это верхняя часть экрана с изображениями, и занимает не более половины экрана.\n   Когда картинка одна, то в масштабировании нет смысла, ведь она и так примет допустимый размер экрана. Но если картинки две и более — нужно их размещать относительно друг друга.\n   Для примера представим голубой фон, ветку дерева и птичку. Три разных картинки, где фон занимает весь размер экрана, а птица и ветка должны быть маленькими на нём. Добавляем три картинки через штатный интерфейс \"Добавить картинку\" и задаём в каждом из них имена (для примера fon, bird, tree). \n   При добавлении картинок, они берут свой оригинальный размер, если он не превышает размеры канваса. Чтобы изменить этот размер нужно: \n  \n   images.bird.width = 200\n   images.bird.height = 300\n  \n   ",
    "answers": [
      {
        "id": 79,
        "text": "Назад",
        "comment": false
      }
    ]
  },
  {
    "id": 81,
    "text": "   Данный режим свободно включается/выключается в квесте соответствующей переменной: \n\n   g.fullscreen = 1\n      или\n   g.fullscreen = 0\n\n   Что ж, представляем... В полноэкранном режиме лежит наша картинка, например, размером 500х300. Размеры дисплея у каждого телефона свои, и поэтому одна и та же картинка будет по разному смотреться на разных телефонах. Ну, то есть, можете представить 500х300 на экране 1024х768, или на экране 2158х1080. В первом случае она займёт половину дисплея игрока, а во втором случае чуть больше четверти.\n   Перейдём к картинке и её размерам. На ответе с картинкой нужно писать имя-идентификатор, например, nemo.\n   Теперь можно обратиться к картинке:\n\n   images.nemo.width = 200\n   images.nemo.height = 300\n\n   Почему images.nemo? Все добавленные картинки хранятся в таблице images, а записанное имя-идентификатор позволяет управлять именно определённой картинкой, а именно nemo. \n   Тут я вручную изменил размер картинки, в пикселях. Важно знать, что само качество картинки никуда не исчезает и всегда остаётся без изменений, сколько её размеры внутри квеста не меняй. А как же сделать универсальный размер картинки, чтобы он на различных экранах имел одинаковый размер? Легко:\n\n   images.nemo.width = display.contentWidth / 4\n\n   display.contentWidth — хранит в себе ширину экрана устройства, а разделив это значение на 4 — я получаю всегда стандартное значение в 1/4 ширины экрана.\n   То же самое, но только для высоты экрана: display.contentHeight.\n   Если меняете width картинки, то не забывайте и о height:\n\n   images.nemo.height = (images.nemo.height / images.nemo.width) * display.contentWidth / 4\n\n   Зачем так сложно? Чтобы соблюсти пропорции картинки, а не превратить её в квадрат. Изначальный размер 500х300, и если, условно, я ширине и высоте дам одинаковое значение, то картинка станет квадратной. ",
    "answers": [
      {
        "id": 82,
        "text": "Далее"
      },
      {
        "id": 79,
        "text": "Назад"
      },
      {
        "id": 81,
        "text": "   ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В меню",
        "comment": false
      }
    ]
  },
  {
    "id": 82,
    "text": "    Теперь обратимся к сжатию: xScale и yScale.\n  \n   xScale = 0.5\n   yScale = 1\n\n   Их значение может принимать любые дробные значения от 0 до бесконечности. \n   Значение 1 говорит о их истинном размере (без сжатия). \n   Значение 0.5 — сжато до 50% от текущего размера в width и height. \n   Значение 0.01 — это 1% от размера картинки. \n   Значение 1.5 — на 50% больше. \n   Значение 3 — это уже 300%... и т.д. \n\n   Использовать Скейл хорошо там, где не нужно менят значений высоты и ширины картинки, например, в анимациях и эффектах (transition.to).\n\n\n   Ещё осталось понять местоположение. Х и У — координаты, исходя от верхнего левого угла. Изначально, добавленная картинка принимает координаты центра дисплея. Можно изменить их вручную, но нужно правильно понимать куда именно перемещать.\n   Любое увеличение X — заставляет картинку сдвинуться вправо. Любое увеличение У — сдвигает картинку вниз. \n\n   images.nemo.x = 200\n   images.nemo.y = 300\n\n   Это значит, что картинка сдвинется по Х на 200 пикселей вправо, а по координате У на 300 пикселей вниз.\n   Координаты также можно задавать и пропорциями экрана:\n\n   images.nemo.x = display.contentWidth / 4\n   images.nemo.y = display.contentHeight / 3\n\n   В таком случае точка Х будет на 1/4 ширины дисплея от его левого края. А высота будет на 1/3 от верхнего края. ",
    "answers": [
      {
        "id": 83,
        "text": "Подытожим"
      },
      {
        "id": 81,
        "text": "Назад "
      },
      {
        "id": 82,
        "text": "   ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В меню",
        "comment": false
      }
    ]
  },
  {
    "id": 83,
    "text": "   Кажется сложным? Как бы не так! Смотри:\n\n   images.nemo.width = 300\n   images.nemo.height = 450\n   images.nemo.x = display.contentWidth * 0.8\n   images.nemo.y = display.contentHeight / 4\n  \n   Ну как? Выходит картинка, размером 450х300, будет располагаться в правой верхней четверти дисплея.\n\n   Подсказка:\n      х — 0.8 от ширины дисплея, считаем слева на право, \n      у = 1/4 высоты дисплея, считает от верха к низу. ",
    "answers": [
      {
        "id": 82,
        "text": "Назад"
      },
      {
        "id": 83,
        "text": "   ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В меню",
        "comment": false
      }
    ]
  },
  {
    "id": 84,
    "text": "   Эта опция запускает страницу, которую Вы запишете как страницу для перезапуска функций. Это может быть любая страница. Запишите на ней все свои функции, которые используете в квесте.\n   Например, если я разместил все свои функции на странице 6, то запись должна быть такой:\n\n   g.reloadFunctions = 6\n\n   Его нужно записать в calculate или в ответ, и желательно в самом начале, чтобы и игрок сразу нажал на неё, и у него тоже включилась эта опция.\n   Сразу эта опция не работает, так как она срабатывает один раз в момент запуска квеста. То есть, нужно выйти и зайти в квест заново. Опция сработает и обновит функции, чтобы те могли работать.\n  \n   Предчувствуя вопрос \"А почему функции надо перезапускать?\" — отвечу, что функции работают только до выхода из квеста. Они записываются в память устройства, а потом загружаются как строка с текстом, а не функция. Такое испольнение сразу выдавало ошибку и краш приложения. И для того, чтобы избежать этого сделали reloadFunctions! ",
    "answers": [
      {
        "id": 5,
        "text": "Назад "
      }
    ]
  },
  {
    "id": 85,
    "text": "   Каждый объект имеет свойство setFillColor, который отвечает за цвет объекта. Допустим, что мы добавляем на экран новый обект — круг.\n\n   myCircle = display.newCircle(200, 200, 100)\n\n   Пояснение: в создание нового круга display.newCircle переданы параметры 200, 200 и 100, где это значения по координатете Х, по координате У и диаметр круга.\n   На экране появится белый круг. А если нужен красный?\n  \n   myCircle:setFillColor(1,0,0)\n\n   Цвет круга изменится после применения метода setFillColor на красный. Но как ориентироваться в цветах?\n   Открываем палитру RGB в любом браузере в поисковике. Находим нужный цвет и смотрим параметры. Обычно там цифры от 0 до 255, а нам нужно давать значения в setFillColor от 0 до 1.\n   Тут всё просто: делим нужное значение на 255. Например, я выбрал цвет изумрудно-зелёный и мне дали значения RGB — 51, 204, 0. Делим каждый:\n\n   51 / 255 = 0.2\n   204 / 255 = 0.8\n   0 / 255 = 0\n\n   Всё, что остаётся, так это ввести эти значения в setFillColor:\n\n   myCircle:setFillColor(0.2, 0.8, 0)\n\n   Если результат деления имеет значение с большим количеством цифр после \"запятой\", то немного округлите для удобства. Например, значение 0.3456789 можно округлить до 0.347. При этом на цвете это скажется незначительно, если вообще заметите разницу.",
    "answers": [
      {
        "id": 86,
        "text": "Примеры цветов",
        "var_set": [
          "global fullscreen",
          1
        ]
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 86,
    "text": "    ",
    "answers": [
      {
        "id": 5,
        "text": "nemo",
        "url": "http://188.120.236.127/hc/3in1game/img/pony44.png"
      },
      {
        "super_calculate": false,
        "lua_do": "function lua_do()\n   images.nemo.isVisible = false\nend",
        "text": "   ",
        "calculate": true,
        "id": 86
      },
      {
        "super_calculate": false,
        "id": 86,
        "text": "   ",
        "calculate": true,
        "lua_do": "function lua_do()\n   myCircle = {}\n\n   sw = display.contentWidth\n   sh = display.contentHeight\n   myCoordX = {canvas.x - canvas.width* 0.75, canvas.x - canvas.width*0.5, canvas.x - canvas.width *0.25}\n   myCoordY = {canvas.y - canvas.height*0.85, canvas.y - canvas.height*0.7, canvas.y - canvas.height*0.55, canvas.y - canvas.height*0.4, canvas.y - canvas.height*0.25}\n   countX = 1\n   countY = 1\n\n   myColors = {\n      {1,0.8,0.8}, {1,0.6,0.6}, {1,0.4,0.4}, {1,0.2,0.2}, {1,0,0},\n      {0.8,1,0.8}, {0.6,1,0.6}, {0.4,1,0.4}, {0.2,1,0.2}, {0,1,0},\n      {0.8,0.8,1}, {0.6,0.6,1}, {0.4,0.4,1}, {0.2,0.2,1}, {0,0,1},\n   } \n\n   for i = 1,15 do\n      myCircle[i] = display.newCircle (myCoordX[countX], myCoordY[countY], canvas.height*0.05)\n      myCircle[i]:setFillColor (myColors[i][1], myColors[i][2], myColors[i][3])\n      canvas:insert(myCircle[i])\n      countX = countX <plus> 1\n      if countX > 3 then\n         countX = 1\n         countY = countY <plus> 1\n      end \n   end \nend"
      },
      {
        "id": 85,
        "text": "Назад",
        "var_set": [
          "global fullscreen",
          0
        ]
      },
      {
        "super_calculate": false,
        "id": 86,
        "text": "   ",
        "calculate": true,
        "lua_do": "function lua_do()\n   for i = 1,15 do\n      myCircle[i]:addEventListener(\"tap\", function()  \n         message(\"  Цвет: \" .. myColors[i][1] .. \", \" .. myColors[i][2] .. \", \" .. myColors[i][3])\n      end)\n   end \nend"
      },
      {
        "id": 86,
        "text": "Нажми на круг, чтобы увидеть параметры цвета",
        "comment": true
      }
    ]
  },
  {
    "id": 87,
    "text": "Здесь вы найдëте основу основ, так сказать БАЗУ, необходимую для того, чтобы начать разбираться в Луа на уровне приложения Текстовые Квесты. \n\nИнформация сгруппирована в виде ответов на наиболее частые вопросы от новичков в формате пошаговой инструкции с пояснениями.\nПригодится, если вы вообще никогда не занимались программированием.",
    "answers": [
      {
        "id": 87,
        "instant": true,
        "text": "Как написать код, чтобы он заработал?",
        "var_set": [
          "c1",
          1,
          "c2",
          0,
          "c3",
          0,
          "c4",
          0,
          "c5",
          0
        ]
      },
      {
        "id": 87,
        "text": "\nfunction lua_do()\n  code\nend",
        "comment": true,
        "var_need": [
          "c1",
          1
        ]
      },
      {
        "id": 87,
        "text": "Разбор ответа на предыдущий вопрос\n(организация кода)",
        "instant": true,
        "var_set": [
          "c1",
          0,
          "c2",
          1,
          "c3",
          0,
          "c4",
          0,
          "c5",
          0
        ]
      },
      {
        "id": 87,
        "text": "Чтобы приложение поняло, что вы пишете код, нужно сказать ему об этом. Для этого код нужно заключить внутрь ФУНКЦИИ. Подробнее о функциях читайте у Завра в этом учебнике. Сейчас нам надо знать ТРИ базовых функции:\n\ndo — вычисление\nif — условие видимости ответа\ntext — текст на ответе\n\nНа примере функции do разберем ее принцип действия.\n\n1.Функция имеет неизменяемые начало и конец.\nНачало: function lua_do()\nКонец: end\n\n2. Функция несëт инструкции. Собственно это любой код, который вы напишите внутри, между началом и концом функции.\nЗаметили, что код внутри написан с отступом? Пояснение в ответе про архитектуру кода.\n\n3. Активация функции.\nlua_do — при нажатии на ответ с кодом или оператор calculate на ответе (см учебник по операторам).\nlua_if / lua_text — сразу при загрузке страницы.",
        "comment": true,
        "var_need": [
          "c2",
          1
        ]
      },
      {
        "id": 87,
        "instant": true,
        "text": "Как писать код правильно?\n(архитектура кода)",
        "var_set": [
          "c1",
          0,
          "c2",
          0,
          "c3",
          1,
          "c4",
          0,
          "c5",
          0
        ]
      },
      {
        "id": 87,
        "text": "1. Код пишется латинскими буквами. \n\n2. После первой строки с названием функции (function lua_do) начните новую строку (enter), чтобы начать писать код.\n\n3. Код внутри функции отделяется ДВУМЯ пробелами. Почему?\n\nПотому что внутри базовой функции можно написать не просто вычисления, но и создать другие функции, таким образом вкладывая их друг в друга как матрëшку.\nЧтобы разграничить, какой код относится к какой функции, он пишется на сответствующем ей уровне отступа (два пробела от уровня первой строки функции)\n\nПример вложенных друг в друга функций if с пояснениями (кириллицей):\n\nfunction lua_do() — <$2>старт 0 уровня кода<$1>\n  if then — <$2>старт 1 уровня<$1>\n    code — <$2>код 1 уровня<$1>\n    if then — <$2>старт 2 уровня<$1>\n      code — <$2>код 2 уровня<$1>\n      if then — <$2>старт 3 уровня<$1>\n        code — <$2>код 3 уровня<$1>\n      end — <$2>конец 3 уровня<$1>\n    end — <$2>конец 2 уровня<$1>\n  end — <$2>конец 1 уровня<$1>\nend — <$2>конец 0 уровня<$1>\n\nКаждый уровень отделяется двумя пробелами от предыдущего. Каждая функция замыкается строкой end на том же уровне, что и еë первая строка. Таким образом вы выстраиваете иерархию внутри кода.",
        "comment": true,
        "var_need": [
          "c3",
          1
        ]
      },
      {
        "id": 87,
        "instant": true,
        "text": "Отличие кода Луа от операторов",
        "var_set": [
          "c1",
          0,
          "c2",
          0,
          "c3",
          0,
          "c4",
          1,
          "c5",
          0
        ]
      },
      {
        "id": 87,
        "text": "Операторы = горячие клавиши приложения Текстовые квесты. Это функции lua, вызываемые простой короткой командой.\nПриведëм простой пример.\n\n<$2>оператор:<$1>\nvar set[\"a\", 1]\n\n<$2>код в lua:\n<$1>function lua_do()\n  a = 1\nend\n\nОператоры — более быстрый и простой способ программирования внутри приложения.\n\nКод lua — более тонкий уровень программирования со значительно большими возможностями.",
        "comment": true,
        "var_need": [
          "c4",
          1
        ]
      },
      {
        "instant": true,
        "middle_answer": false,
        "text": "НЕВЕРОЯТНЫЙ ЛАЙФХАК",
        "id": 87,
        "var_set": [
          "c1",
          0,
          "c2",
          0,
          "c3",
          0,
          "c4",
          0,
          "c5",
          1
        ]
      },
      {
        "id": 87,
        "text": "1. Откройте левое меню\nЭто можно сделать, нажав на шестерëнки в левом верхнем углу, либо свайпнув экран от левого края вправо.\n\n2. Нажмите на «Продвинутый режим»\n(Необходимый режим — «активирован»)\n\n3. Закройте левое меню.\n\n4. Теперь, создав новый ответ, вы увидите под полем для ввода текста табличку. Это шаблоны различных функций и операторов.\nВам необходимо найти квадратики lua_do/lua_if/lua_text. Запомните, где они находятся.\n\nНажав на один из них, вы скопируете в поле для ввода шаблон соответствующей базовой функции (начало и конец).\nНачните enter в конце первой строки с названием функции и пишите свой код.",
        "comment": true,
        "var_need": [
          "c5",
          1
        ]
      },
      {
        "id": 87,
        "text": " ",
        "comment": true
      },
      {
        "comment": false,
        "id": 88,
        "text": "Самые частые ошибки",
        "instant": false,
        "left_answer": false
      },
      {
        "id": 12,
        "text": "Следующая ступень LUA",
        "comment": false,
        "right_answer": false
      },
      {
        "id": 87,
        "text": " ",
        "comment": true
      },
      {
        "id": 5,
        "text": "В начало",
        "var_set": [
          "c1",
          0,
          "c2",
          0,
          "c3",
          0,
          "c4",
          0,
          "c5",
          0
        ]
      }
    ]
  },
  {
    "id": 88,
    "text": "Основные ошибки и способы их исправления.\nПеред ознакомлением рекомендуется прочтение уроков Завра.",
    "answers": [
      {
        "id": 88,
        "text": "Общие рекомендации",
        "instant": true,
        "var_set": [
          "a1",
          1,
          "a2",
          0,
          "a3",
          0,
          "a4",
          0,
          "a5",
          0
        ]
      },
      {
        "id": 88,
        "text": "1. Соблюдайте структуру функции:\n\n— Отделяйте код нужным числом пробелов (по два на уровень)\n— Не забывайте все обязательные слова функции (например строка if обязана кончаться then)\n— Каждый уровень функции должен закрываться end на соответствующим функции отступе.\n\n2. Следите за именами переменных. Отличие даже на один знак приведëт к ошибке.\n\n3. Имена переменных записывайте латиницей, либо числительными. Не используйте числительные в начале имени. Хотя бы один знак (первый) должен быть буквой. Это не железное правило, но так вы минимизируете риск ошибки.\n\n4. Объявляйте переменные заранее. Использование в функциях необьявленных переменных может привести к ошибке (так как нельзя сравнить <$2>НИЧТО<$1> с чем-либо.)\nP.S. для продвинутых. Можно не заморачиваться с обьявлением переменных заранее. Вместо одного имени переменной пишите (имя or 0). Пример:\n\nfunction lua_do()\n  if (a or 0) == 1 then\n    b = 1\n  end\nend",
        "comment": true,
        "var_need": [
          "a1",
          1
        ]
      },
      {
        "id": 88,
        "text": " ",
        "comment": true
      },
      {
        "id": 88,
        "text": "Окошко баг-репорта",
        "instant": true,
        "var_set": [
          "a1",
          0,
          "a2",
          1,
          "a3",
          0,
          "a4",
          0,
          "a5",
          0
        ]
      },
      {
        "id": 88,
        "text": "Если в ваш код закралась ошибка, при сохранении ответа вылезет окно с описанием этой ошибки.\n\nКак его понимать:\n— сначала идëт неважная ссылка\n— найдите слова source.lua:ЦИФРА\nЭто номер строки кода, где находится ошибка.\n— после цифры идëт собственно описание проблемы.\n\n\nНиже мы разберëм значение самых распространëнных вариантов ошибок в коде.",
        "comment": true,
        "var_need": [
          "a2",
          1
        ]
      },
      {
        "id": 88,
        "text": "end expected",
        "instant": true,
        "var_set": [
          "a1",
          0,
          "a2",
          0,
          "a3",
          1,
          "a4",
          0,
          "a5",
          0
        ]
      },
      {
        "id": 88,
        "text": "Ошибка: \n'end' expected (to close 'function' at line ЦИФРА)\n\nВы забыли закрыть одну из функций endом.\nЦифра здесь — номер строки, на которой начинается незакрытая функция. ",
        "comment": true,
        "var_need": [
          "a3",
          1
        ]
      },
      {
        "id": 88,
        "text": "syntax error",
        "instant": true,
        "var_set": [
          "a1",
          0,
          "a2",
          0,
          "a3",
          0,
          "a4",
          1,
          "a5",
          0
        ]
      },
      {
        "id": 88,
        "text": "syntax error near 'направильный код'\n\nИспользован неправильный символ. Ошибочный символ заключëн в одиночные кавычки. Остаëтся найти нужную строку (вспомним, еë номер написан здесь: source.lua:НОМЕР) и устранить/заменить неверный символ. ",
        "comment": true,
        "var_need": [
          "a4",
          1
        ]
      },
      {
        "id": 88,
        "text": "attempt to compare number with nil",
        "instant": true,
        "var_set": [
          "a1",
          0,
          "a2",
          0,
          "a3",
          0,
          "a4",
          0,
          "a5",
          1
        ]
      },
      {
        "id": 88,
        "text": "attempt to compare number with nil\n\nПопытка сравнить числительное с НИЧТО (nil). Вероятнее всего вы использовали необьявленную переменную. \nПример : if a > 0 then\nЕсли переменная \"a\" не обьявлена, то ее зрачение по умолчанию nil, то есть еë не существует.\n\nРешение: \n1. Объявите (присвойте какое-либо значение) переменной заранее. Это модно сделать через операторы var add или var set, либо через lua_do:\nvar add[\"a\", 0]\nvar set[\"a\", 0]\nfunction lua_do()\n  a = 0\nend",
        "comment": true,
        "var_need": [
          "a5",
          1
        ]
      },
      {
        "id": 88,
        "text": " ",
        "comment": true
      },
      {
        "id": 87,
        "text": "База Lua"
      },
      {
        "id": 12,
        "text": "Уроки Завра"
      },
      {
        "id": 5,
        "text": "В начало"
      }
    ]
  },
  {
    "id": 89,
    "text": "",
    "answers": []
  },
  {
    "id": 90,
    "text": "",
    "answers": []
  },
  {
    "id": 91,
    "text": "",
    "answers": []
  },
  {
    "id": 92,
    "text": "",
    "answers": []
  },
  {
    "id": 93,
    "text": "",
    "answers": []
  },
  {
    "id": 94,
    "text": "",
    "answers": []
  }
]